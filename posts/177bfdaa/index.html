<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"howu911.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="docker学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="docker学习笔记">
<meta property="og:url" content="https://howu911.github.io/posts/177bfdaa/index.html">
<meta property="og:site_name" content="Howu&#39;s Blog">
<meta property="og:description" content="docker学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638767.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051637200.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638438.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638120.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638835.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639300.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639442.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639291.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639986.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639430.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639232.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639385.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640263.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640095.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640250.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640955.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640057.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640131.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640592.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640521.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640288.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640246.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051641040.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051641647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051641845.png">
<meta property="og:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051641709.png">
<meta property="article:published_time" content="2024-10-05T08:20:26.000Z">
<meta property="article:modified_time" content="2024-10-05T10:43:38.399Z">
<meta property="article:author" content="howu">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638767.png">


<link rel="canonical" href="https://howu911.github.io/posts/177bfdaa/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://howu911.github.io/posts/177bfdaa/","path":"posts/177bfdaa/","title":"docker学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>docker学习笔记 | Howu's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Howu's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">Docker概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-number">1.1.</span> <span class="nav-text">docker的基本组成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker%E5%91%BD%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">Docker命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">镜像命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">容器命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%AE%B9%E5%99%A8%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">新建容器并启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%85%B6%E5%AE%83%E5%91%BD%E4%BB%A4"><span class="nav-number">2.2.2.</span> <span class="nav-text">常用其它命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">后台启动容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">查看日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">查看容器中的进程信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">查看容器属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">进入当前正在运行的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">容器拷贝文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="nav-number">2.2.2.7.</span> <span class="nav-text">查看端口映射</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%94%AF%E6%92%91%E6%8A%80%E6%9C%AF-namespace"><span class="nav-number">3.</span> <span class="nav-text">容器支撑技术-namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="nav-number">3.1.</span> <span class="nav-text">容器与进程间关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8Bnamespace%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">查看进程namespace的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UTS-namespace"><span class="nav-number">3.3.</span> <span class="nav-text">UTS namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.3.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">内核中的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC-Namespace"><span class="nav-number">3.4.</span> <span class="nav-text">IPC Namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PID-Namespace"><span class="nav-number">3.5.</span> <span class="nav-text">PID Namespace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mount-Namespace"><span class="nav-number">3.6.</span> <span class="nav-text">Mount Namespace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#User-Namespace"><span class="nav-number">3.7.</span> <span class="nav-text">User Namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAuser-namespace"><span class="nav-number">3.7.1.</span> <span class="nav-text">创建user namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84user-ID%E5%92%8Cgroup-ID"><span class="nav-number">3.7.2.</span> <span class="nav-text">映射user ID和group ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network-Namespace"><span class="nav-number">3.8.</span> <span class="nav-text">Network Namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">3.8.1.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%94%AF%E6%92%91%E6%8A%80%E6%9C%AF-cgroup"><span class="nav-number">4.</span> <span class="nav-text">容器支撑技术-cgroup</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cgroup%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">cgroup的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgroup%E7%BB%84%E6%88%90"><span class="nav-number">4.2.</span> <span class="nav-text">cgroup组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgroup%E8%A7%84%E5%88%99"><span class="nav-number">4.3.</span> <span class="nav-text">cgroup规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgroup%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.4.</span> <span class="nav-text">cgroup子系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">4.5.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%90cgroup"><span class="nav-number">4.5.1.</span> <span class="nav-text">创建子cgroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.5.2.</span> <span class="nav-text">添加进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%99%90%E9%A2%9D"><span class="nav-number">4.5.3.</span> <span class="nav-text">设置限额</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">4.6.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E6%94%AF%E6%92%91%E6%8A%80%E6%9C%AF-Union-FS"><span class="nav-number">5.</span> <span class="nav-text">docker支撑技术-Union FS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker%E9%95%9C%E5%83%8F"><span class="nav-number">6.</span> <span class="nav-text">Docker镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.1.</span> <span class="nav-text">镜像是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text">Docker镜像加载原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82"><span class="nav-number">6.3.</span> <span class="nav-text">镜像分层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commit%E9%95%9C%E5%83%8F"><span class="nav-number">6.4.</span> <span class="nav-text">commit镜像</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">docker镜像管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">镜像本地管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#repositories-json"><span class="nav-number">7.1.1.</span> <span class="nav-text">repositories.json</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E9%95%9C%E5%83%8F"><span class="nav-number">7.2.</span> <span class="nav-text">docker容器与镜像</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker%E5%AE%B9%E5%99%A8%E5%8D%B7"><span class="nav-number">8.</span> <span class="nav-text">Docker容器卷</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E5%8D%B7"><span class="nav-number">8.1.</span> <span class="nav-text">什么是容器卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8D%B7"><span class="nav-number">8.2.</span> <span class="nav-text">使用容器卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E8%AF%86Dockerfile"><span class="nav-number">8.3.</span> <span class="nav-text">初识Dockerfile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%97%B4%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">8.4.</span> <span class="nav-text">容器间数据卷</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DockerFile"><span class="nav-number">9.</span> <span class="nav-text">DockerFile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DockerFile%E4%BB%8B%E7%BB%8D"><span class="nav-number">9.1.</span> <span class="nav-text">DockerFile介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DockerFile%E8%AF%AD%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text">DockerFile语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99DockerFile"><span class="nav-number">9.3.</span> <span class="nav-text">编写DockerFile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">9.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker%E7%BD%91%E7%BB%9C"><span class="nav-number">10.</span> <span class="nav-text">Docker网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="nav-number">10.1.</span> <span class="nav-text">端口映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94-%E2%80%93link"><span class="nav-number">10.2.</span> <span class="nav-text">容器互联 –link</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="nav-number">10.3.</span> <span class="nav-text">自定义网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%AE%B9%E5%99%A8%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E8%B7%AF"><span class="nav-number">10.4.</span> <span class="nav-text">添加容器到自定义网路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">11.</span> <span class="nav-text">Docker 运行容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#docker%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="nav-number">11.1.</span> <span class="nav-text">docker进程关系图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docker-creat"><span class="nav-number">11.2.</span> <span class="nav-text">docker creat</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%AE%B9%E5%99%A8%E8%AE%BE%E7%BD%AE%E8%AF%BB%E5%86%99%E5%B1%82"><span class="nav-number">11.2.1.</span> <span class="nav-text">为容器设置读写层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">11.2.2.</span> <span class="nav-text">创建容器配置文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docker-start"><span class="nav-number">11.3.</span> <span class="nav-text">docker start</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87rootfs"><span class="nav-number">11.3.1.</span> <span class="nav-text">准备rootfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BD%91%E7%BB%9C"><span class="nav-number">11.3.2.</span> <span class="nav-text">初始化网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90bundle%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">11.3.3.</span> <span class="nav-text">生成bundle配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7"><span class="nav-number">11.3.4.</span> <span class="nav-text">容器监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shim"><span class="nav-number">11.3.5.</span> <span class="nav-text">shim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runc"><span class="nav-number">11.3.6.</span> <span class="nav-text">runc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="nav-number">11.3.6.1.</span> <span class="nav-text">创建容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">11.3.6.2.</span> <span class="nav-text">启动容器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#other"><span class="nav-number">12.</span> <span class="nav-text">other</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#container-shim%E8%BF%9B%E7%A8%8B%E5%8F%82%E6%95%B0"><span class="nav-number">12.1.</span> <span class="nav-text">container-shim进程参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E6%96%87%E4%BB%B6"><span class="nav-number">12.2.</span> <span class="nav-text">io文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E6%96%87%E4%BB%B6"><span class="nav-number">12.3.</span> <span class="nav-text">运行状态文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-1"><span class="nav-number">13.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">howu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://howu911.github.io/posts/177bfdaa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="howu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Howu's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="docker学习笔记 | Howu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          docker学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-10-05 16:20:26 / 修改时间：18:43:38" itemprop="dateCreated datePublished" datetime="2024-10-05T16:20:26+08:00">2024-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>docker学习笔记</p>
<span id="more"></span>

<h1 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h1><h2 id="docker的基本组成"><a href="#docker的基本组成" class="headerlink" title="docker的基本组成"></a>docker的基本组成</h2><p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638767.png" alt="请添加图片描述"></p>
<p><strong>镜像</strong></p>
<p>镜像只是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建很多容器（最终的服务或项目是运行在容器中的）</p>
<p><strong>容器</strong></p>
<p>Docker利用容器独立运行的一个或一组应用。容器是用镜像创建的运行实例。每个容器都是相互隔离的，保证安全的平台。可以把容器看作是一个简易版的Linux环境(包括root用户权限，进程空间，用户空间和网络空间等)和运行在其中的应用程序。</p>
<p><strong>仓库</strong></p>
<p>仓库是集中存放镜像文件的场所。</p>
<p>docker仓库类似于github，有共有仓库和私有仓库。Docker Hub（国外）阿里云（国内）。</p>
<h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>docker images</strong>  查看本机所有的镜像</p>
<p><strong>docker search</strong>  搜索镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu ~&gt; docker search ubuntu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可添加过滤规则</span></span><br><span class="line">--filter=STARS=3000</span><br><span class="line">howu@howu-ubuntu ~&gt; docker search ubuntu --filter=STARS=3000</span><br><span class="line">NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">ubuntu              Ubuntu is a Debian-based Linux operating sys…   11515               [OK]</span><br></pre></td></tr></table></figure>



<p><strong>docker pull</strong>  获取镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu ~&gt; docker pull ubuntu</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">6a5697faee43: Pull complete</span><br><span class="line">ba13d3bc422b: Pull complete</span><br><span class="line">a254829d9e55: Pull complete</span><br><span class="line">Digest: sha256:fff16eea1a8ae92867721d90c59a75652ea66d29c05294e6e2f898704bdb8cf1</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br><span class="line">docker.io/library/ubuntu:latest</span><br></pre></td></tr></table></figure>



<p><strong>docker rmi</strong>  删除镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu ~&gt; docker rmi db2b37ec6181</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:8c17271df53ee3b843d6e16d46cff13f22c9c04d6982eb15a9a47bd5c9ac7e2d</span><br><span class="line">Deleted: sha256:db2b37ec6181ee1f367363432f841bf3819d4a9f61d26e42ac16e5bd7ff2ec18</span><br><span class="line">Deleted: sha256:4d2a8e0ab441c5c1170a783be98b47096324f531f84cc387f06523af79ee7cd5</span><br><span class="line">Deleted: sha256:09e5f20e5b3289cedaf4824906f74057b5b9b8765a246d8bfaafded2562a901a</span><br><span class="line">Deleted: sha256:c25bdaaaf298842706f214fd3d855ca6f215cc66d01345efb9fd7479f6ca7b5f</span><br><span class="line">Deleted: sha256:64231a7235fe05862b419beb8884dec599d27cab1b1bb402f0f75e64bc4cbd19</span><br><span class="line">Deleted: sha256:79bc33a7ecad0032cc5e218d8b246b645f4cfddbf639b5db8383f81d4cbb6c9b</span><br><span class="line">Deleted: sha256:33134afe9e842a2898e36966f222fcddcdb2ab42e65dcdc581a4b38b2852c2e0</span><br><span class="line">Deleted: sha256:dd053ec71039c3646324372061452778609b9ba42d1501f6a72c0272c94f8965</span><br><span class="line">Deleted: sha256:2d4c647f875f6256f210459e5c401aad27ad223d0fa3bada7c4088a6040f8ba4</span><br><span class="line">Deleted: sha256:4bded7e9aa769cb0560e60da97421e2314fa896c719179b926318640324d7932</span><br><span class="line">Deleted: sha256:5fd9447ef700dfe5975c4cba51d3c9f2e757b34782fe145c1d7a12dfbee1da2f</span><br><span class="line">Deleted: sha256:5ee7cbb203f3a7e90fe67330905c28e394e595ea2f4aa23b5d3a06534a960553</span><br><span class="line">Deleted: sha256:d0fe97fa8b8cefdffcef1d62b65aba51a6c87b6679628a2b50fc6a7a579f764c</span><br></pre></td></tr></table></figure>





<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a><strong>新建容器并启动</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot;   指定容器的名字  </span><br><span class="line">-d				后台方式运行</span><br><span class="line">-it				使用交互模式运行</span><br><span class="line">--rm			容器在终止后立即删除容器，不能与-d参数同时使用</span><br><span class="line">-p</span><br><span class="line">	-p ip:主机端口：容器端口</span><br><span class="line">	-p 主机端口：容器端口</span><br><span class="line">	-p 容器端口</span><br><span class="line">-P				随机指定端口</span><br><span class="line">howu@howu-ubuntu ~&gt; docker run -it ubuntu /bin/bash</span><br><span class="line">root@49c2189c70c8:/#</span><br></pre></td></tr></table></figure>

<p>容器端口映射：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/panwenbin-logs/p/11205614.html">https://www.cnblogs.com/panwenbin-logs/p/11205614.html</a></p>
<p><strong>列出所有运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu ~&gt; docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">49c2189c70c8        ubuntu              &quot;/bin/bash&quot;         5 minutes ago       Up 5 minutes                            zealous_goldberg</span><br><span class="line">howu@howu-ubuntu ~&gt;</span><br><span class="line">howu@howu-ubuntu ~&gt;</span><br><span class="line">howu@howu-ubuntu ~&gt; docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                  PORTS               NAMES</span><br><span class="line">49c2189c70c8        ubuntu              &quot;/bin/bash&quot;         5 minutes ago       Up 5 minutes                                zealous_goldberg</span><br><span class="line">9e034b52cfe7        centos:latest       &quot;/bin/bash&quot;         2 days ago          Exited (0) 2 days ago                       objective_chaum</span><br><span class="line">0088f5db4629        hello-world         &quot;/hello&quot;            3 days ago          Exited (0) 3 days ago                       determined_albattani</span><br></pre></td></tr></table></figure>



<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit     #容器停止并退出</span><br><span class="line">Ctrl + P + Q    # 容器不停止退出</span><br></pre></td></tr></table></figure>



<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器ID</span><br><span class="line">docker rm -f $(docker ps -aq)   #删除所有的容器</span><br></pre></td></tr></table></figure>



<p><strong>启动和停止容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID</span><br><span class="line">docker restart 容器ID</span><br><span class="line">docker stop 容器ID</span><br><span class="line">docker kill 容器ID</span><br></pre></td></tr></table></figure>



<h3 id="常用其它命令"><a href="#常用其它命令" class="headerlink" title="常用其它命令"></a>常用其它命令</h3><h4 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a><strong>后台启动容器</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 镜像名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker 容器使用后台运行，就必须要有一个前台的进程，docker发现没有应用，就会自动停止</span></span><br></pre></td></tr></table></figure>



<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a><strong>查看日志</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -tf --tail 10 容器ID</span><br></pre></td></tr></table></figure>



<h4 id="查看容器中的进程信息"><a href="#查看容器中的进程信息" class="headerlink" title="查看容器中的进程信息"></a><strong>查看容器中的进程信息</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure>



<h4 id="查看容器属性"><a href="#查看容器属性" class="headerlink" title="查看容器属性"></a><strong>查看容器属性</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>



<h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a><strong>进入当前正在运行的容器</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式一  进入容器后会开启一个新的终端，可以在里面操作</span></span><br><span class="line">docker exec -it 容器ID bashShell</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式二  进入容器正在执行的终端，不会启动新的进程</span></span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure>



<h4 id="容器拷贝文件"><a href="#容器拷贝文件" class="headerlink" title="容器拷贝文件"></a><strong>容器拷贝文件</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往容器内拷贝</span></span><br><span class="line">howu@howu-ubuntu ~/g/s/hello&gt; docker cp hello 49c2189c70c8:/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往容器外拷贝</span></span><br><span class="line">docker cp 49c2189c70c8:/ljt.txt ./</span><br></pre></td></tr></table></figure>



<h4 id="查看端口映射"><a href="#查看端口映射" class="headerlink" title="查看端口映射"></a>查看端口映射</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port 容器名 端口名</span><br></pre></td></tr></table></figure>





<h1 id="容器支撑技术-namespace"><a href="#容器支撑技术-namespace" class="headerlink" title="容器支撑技术-namespace"></a>容器支撑技术-namespace</h1><p>目前linux内核支持7种不同类型的namespace。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">名称        宏定义             隔离内容</span><br><span class="line">Cgroup      CLONE_NEWCGROUP   Cgroup root directory (since Linux 4.6)</span><br><span class="line">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues (since Linux 2.6.19)</span><br><span class="line">Network     CLONE_NEWNET      Network devices, stacks, ports, etc. (since Linux 2.6.24)</span><br><span class="line">Mount       CLONE_NEWNS       Mount points (since Linux 2.4.19)</span><br><span class="line">PID         CLONE_NEWPID      Process IDs (since Linux 2.6.24)</span><br><span class="line">User        CLONE_NEWUSER     User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8)</span><br><span class="line">UTS         CLONE_NEWUTS      Hostname and NIS domain name (since Linux 2.6.19)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps: Cgroup现在在docker中还未使用</p>
</blockquote>
<h2 id="容器与进程间关系"><a href="#容器与进程间关系" class="headerlink" title="容器与进程间关系"></a>容器与进程间关系</h2><p>首先明确一点：容器不能脱离进程而存在，先有进程，后有容器。<br>然而，大家往往会说到“使用Docker创建Docker Container（容器），然后在容器内部运行进程”。对此，从通俗易懂的角度来讲，这完全可以理解，因为“容器”一词的存在，本身就较为抽象。如果需要更为准确的表述，那么可以是：使用Docker创建一个进程，为这个进程创建隔离的环境，这样的环境可以称为Docker Container（容器），然后再在容器内部运行用户应用进程。</p>
<h2 id="查看进程namespace的方式"><a href="#查看进程namespace的方式" class="headerlink" title="查看进程namespace的方式"></a>查看进程namespace的方式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/[pid]/ns</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051637200.png" alt="在这里插入图片描述"></p>
<p>Linux可以为docker提供的namespace种类包括文件系统mount、进程间通信、网络等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GUN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h2><p>UTS(<strong>UNIX Timesharing System</strong>)命名空间是Linux内核Namespace（命名空间）的一个子系统，主要用来完成对容器HOSTNAME和domain的隔离，同时保存内核名称、版本、以及底层体系结构类型等信息。<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638438.png" alt="在这里插入图片描述"></p>
<p>UTS命名空间是扁平化的结构，不同的命名空间之间没有层级关系。<br>UTS namespace没有嵌套关系，即不存在说一个namespace是另一个namespace的父namespace。</p>
<p>UTS命名空间的用来隔离系统的这些信息，使得用户在容器中查看到的信息是当前容器的系统、版本，不同于主机的，内核通过uts_namespace对当前系统中多个容器的这些信息进行统一管理，每一个容器对应有一个自己的uts_namespace，用来隔离容器的内核名称、版本等信息，不同容器查看到的都是属于自己的信息，相互间不能查看</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);    #？</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改主机名成功</p>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638120.png" alt="请添加图片描述"></p>
<h3 id="内核中的实现"><a href="#内核中的实现" class="headerlink" title="内核中的实现"></a>内核中的实现</h3><p>在每一个任务对应的task结构体<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h">struct task_struct</a>中，有一个字段专门用来描述该任务所处的用户空间，该字段为<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h">struct nsproxy</a>，以下为关键代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Namespaces: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>			*<span class="title">nsproxy</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure to contain pointers to all per-process</span></span><br><span class="line"><span class="comment"> * namespaces - fs (mount), uts, network, sysvipc, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pid namespace is an exception -- it&#x27;s accessed using</span></span><br><span class="line"><span class="comment"> * task_active_pid_ns.  The pid namespace here is the</span></span><br><span class="line"><span class="comment"> * namespace that children will use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of tasks holding a reference.</span></span><br><span class="line"><span class="comment"> * The count for each namespace, then, will be the number</span></span><br><span class="line"><span class="comment"> * of nsproxies pointing to it, not the number of tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The nsproxy is shared by tasks which share all namespaces.</span></span><br><span class="line"><span class="comment"> * As soon as a single namespace is cloned or unshared, the</span></span><br><span class="line"><span class="comment"> * nsproxy is copied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns_for_children</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> 	     *<span class="title">net_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_namespace</span> *<span class="title">cgroup_ns</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> new_utsname *<span class="title function_">utsname</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;current-&gt;nsproxy-&gt;uts_ns-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(gethostname, <span class="type">char</span> __user *, name, <span class="type">int</span>, len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">new_utsname</span> *<span class="title">u</span>;</span></span><br><span class="line">	<span class="type">char</span> tmp[__NEW_UTS_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	down_read(&amp;uts_sem);</span><br><span class="line">	u = utsname();</span><br><span class="line">	i = <span class="number">1</span> + <span class="built_in">strlen</span>(u-&gt;nodename);</span><br><span class="line">	<span class="keyword">if</span> (i &gt; len)</span><br><span class="line">		i = len;</span><br><span class="line">	<span class="built_in">memcpy</span>(tmp, u-&gt;nodename, i);</span><br><span class="line">	up_read(&amp;uts_sem);</span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(name, tmp, i))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h2><p>IPC资源一般就是进程间通讯所使用的内核资源，常用的有以下几种：</p>
<ul>
<li>管道</li>
<li>信号</li>
<li>共享存储映射</li>
<li>socket</li>
<li>消息队列<br>而IPC namespace就是用来隔离这些资源。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">记下默认的uts和ipc namespace number</span></span><br><span class="line">dev@ubuntu:~$ readlink /proc/$$/ns/uts /proc/$$/ns/ipc</span><br><span class="line">uts:[4026531838]</span><br><span class="line">ipc:[4026531839]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">确认hostname</span></span><br><span class="line">dev@ubuntu:~$ hostname</span><br><span class="line">ubuntu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看现有的ipc Message Queues，默认情况下没有message queue</span></span><br><span class="line">dev@ubuntu:~$ ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个message queue</span></span><br><span class="line">dev@ubuntu:~$ ipcmk -Q</span><br><span class="line">Message queue id: 0</span><br><span class="line">dev@ubuntu:~$ ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line">0x12aa0de5 0          dev        644        0            0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第二个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新打开一个shell窗口，确认和上面的shell是在同一个namespace，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">能看到上面创建的message queue</span></span><br><span class="line">dev@ubuntu:~$ readlink /proc/$$/ns/uts /proc/$$/ns/ipc</span><br><span class="line">uts:[4026531838]</span><br><span class="line">ipc:[4026531839]</span><br><span class="line">dev@ubuntu:~$ ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line">0x12aa0de5 0          dev        644        0            0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行unshare创建新的ipc和uts namespace，并且在新的namespace中启动bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里-i表示启动新的ipc namespace，-u表示启动新的utsnamespace</span></span><br><span class="line">dev@ubuntu:~$ sudo unshare -iu /bin/bash</span><br><span class="line">root@ubuntu:~#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">确认新的bash已经属于新的ipc和uts namespace了</span></span><br><span class="line">root@ubuntu:~# readlink /proc/$$/ns/uts /proc/$$/ns/ipc</span><br><span class="line">uts:[4026532455]</span><br><span class="line">ipc:[4026532456]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置新的hostname以便和第一个shell里面的bash做区分</span></span><br><span class="line">root@ubuntu:~# hostname container001</span><br><span class="line">root@ubuntu:~# hostname</span><br><span class="line">container001</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当hostname改变后，bash不会自动修改它的命令行提示符</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以运行<span class="built_in">exec</span> bash重新加载bash</span></span><br><span class="line">root@ubuntu:~# exec bash</span><br><span class="line">root@container001:~#</span><br><span class="line">root@container001:~# hostname</span><br><span class="line">container001</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">现在各个bash进程间的关系如下</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bash(24429)是shell窗口打开时的bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bash(27668)是运行<span class="built_in">sudo</span> unshare创建的bash，和bash(24429)不在同一个namespace</span></span><br><span class="line">root@container001:~# pstree -pl</span><br><span class="line">├──sshd(24351)───sshd(24428)───bash(24429)───sudo(27667)───bash(27668)───pstree(27695)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看message queues，看不到原来namespace里面的消息，说明已经被隔离了</span></span><br><span class="line">root@container001:~# ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一条新的message queue</span></span><br><span class="line">root@container001:~# ipcmk -Q</span><br><span class="line">Message queue id: 0</span><br><span class="line">root@container001:~# ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line">0x54b08fc2 0          root       644        0            0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到第一个shell窗口，看看有没有受到新namespace的影响</span></span><br><span class="line">dev@ubuntu:~$ ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line">0x12aa0de5 0          dev        644        0            0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">完全无影响，还是原来的信息</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">试着加入第二个shell窗口里面bash的uts和ipc namespace</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-t后面跟pid用来指定加入哪个进程所在的namespace</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里27668是第二个shell中正在运行的bash的pid</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">加入成功后将运行/bin/bash</span></span><br><span class="line">dev@ubuntu:~$ sudo nsenter -t 27668 -u -i /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">加入成功，bash的提示符也自动变过来了</span></span><br><span class="line">root@container001:~# readlink /proc/$$/ns/uts /proc/$$/ns/ipc</span><br><span class="line">uts:[4026532455]</span><br><span class="line">ipc:[4026532456]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示的是新namespace里的message queues</span></span><br><span class="line">root@container001:~# ipcs -q</span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line">0x54b08fc2 0          root       644        0            0</span><br></pre></td></tr></table></figure>

<h2 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h2><p>PID namespace用来隔离进程的id信息，使得不同pid namespace里的进程ID可以重复且相互之间不影响。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前pid namespace的ID</span></span><br><span class="line">dev@ubuntu:~$ readlink /proc/self/ns/pid</span><br><span class="line">pid:[4026531836]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动新的pid namespace</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里同时也启动了新的uts和mount namespace</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新的uts是为了设置一个新的hostname，便于和老的namespace区分</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新的mount namespace是为了方便我们修改新namespace里面的mount信息，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">因为这样不会对老namespace造成影响</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里--fork是为了让unshare进程fork一个新的进程出来，然后再用bash替换掉新的进程</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是pid namespace本身的限制，进程所属的pid namespace在它创建的时候就确定了，不能更改，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以调用unshare和nsenter后，原来的进程还是属于老的namespace，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">而新fork出来的进程才属于新的namespace</span></span><br><span class="line">dev@ubuntu:~$ sudo unshare --uts --pid --mount --fork /bin/bash</span><br><span class="line">root@ubuntu:~# hostname container001</span><br><span class="line">root@ubuntu:~# exec bash</span><br><span class="line">root@container001:~#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看进程间关系，当前bash(31646)确实是unshare的子进程</span></span><br><span class="line">root@container001:~# pstree -pl</span><br><span class="line">├─sshd(955)─┬─sshd(17810)───sshd(17891)───bash(17892)───sudo(31644)──</span><br><span class="line">─unshare(31645)───bash(31646)───pstree(31677)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">他们属于不同的pid namespace</span></span><br><span class="line">root@container001:~# readlink /proc/31645/ns/pid</span><br><span class="line">pid:[4026531836]</span><br><span class="line">root@container001:~# readlink /proc/31646/ns/pid</span><br><span class="line">pid:[4026532469]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但为什么通过这种方式查看到的namespace还是老的呢？</span></span><br><span class="line">root@container001:~# readlink /proc/$$/ns/pid</span><br><span class="line">pid:[4026531836]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由于我们实际上已经是在新的namespace里了，并且当前bash是当前namespace的第一个进程</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以在新的namespace里看到的他的进程ID是1</span></span><br><span class="line">root@container001:~# echo $$</span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但由于我们新的namespace的挂载信息是从老的namespace拷贝过来的，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以这里看到的还是老namespace里面的进程号为1的信息</span></span><br><span class="line">root@container001:~# readlink /proc/1/ns/pid</span><br><span class="line">pid:[4026531836]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ps命令依赖/proc目录，所以ps的输出还是老namespace的视图</span></span><br><span class="line">root@container001:~# ps ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 7月07 ?       00:00:06 /sbin/init</span><br><span class="line">root         2     0  0 7月07 ?       00:00:00 [kthreadd]</span><br><span class="line"> ...</span><br><span class="line">root     31644 17892  0 7月14 pts/0   00:00:00 sudo unshare --uts --pid --mount --fork /bin/bash</span><br><span class="line">root     31645 31644  0 7月14 pts/0   00:00:00 unshare --uts --pid --mount --fork /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以我们需要重新挂载我们的/proc目录</span></span><br><span class="line">root@container001:~# mount -t proc proc /proc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新挂载后，能看到我们新的pid namespace ID了</span></span><br><span class="line">root@container001:~# readlink /proc/$$/ns/pid</span><br><span class="line">pid:[4026532469]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ps的输出也正常了</span></span><br><span class="line">root@container001:~# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 7月14 pts/0   00:00:00 bash</span><br><span class="line">root        44     1  0 00:06 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<p>PID namespace可以嵌套，也就是说有父子关系，在当前namespace里面创建的所有新的namespace都是当前namespace的子namespace。父namespace里面可以看到所有子孙后代namespace里的进程信息，而子namespace里看不到祖先或者兄弟namespace里的进程信息。</p>
<p>目前PID namespace最多可以嵌套32层，由内核中的宏MAX_PID_NS_LEVEL来定义。</p>
<p>调用unshare或者setns函数后，当前进程的namespace不会发生变化，不会加入到新的namespace，而它的子进程会加入到新的namespace。也就是说进程属于哪个namespace是在进程创建的时候决定的，并且以后再也无法更改。</p>
<p>在一个PID namespace里的进程，它的父进程可能不在当前namespace中，而是在外面的namespace里面（这里外面的namespace指当前namespace的祖先namespace），这类进程的ppid都是0。比如新namespace里面的第一个进程，他的父进程就在外面的namespace里。通过setns的方式加入到新namespace中的进程的父进程也在外面的namespace中。</p>
<p>可以在祖先namespace中看到子namespace的所有进程信息，且可以发信号给子namespace的进程，但进程在不同namespace中的PID是不一样的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">记下最外层的namespace ID</span></span><br><span class="line">dev@ubuntu:~$ readlink /proc/$$/ns/pid</span><br><span class="line">pid:[4026531836]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建新的pid namespace， 这里--mount-proc参数是让unshare自动重新mount /proc目录</span></span><br><span class="line">dev@ubuntu:~$ sudo unshare --uts --pid --mount --fork --mount-proc /bin/bash</span><br><span class="line">root@ubuntu:~# hostname container001</span><br><span class="line">root@ubuntu:~# exec bash</span><br><span class="line">root@container001:~# readlink /proc/$$/ns/pid</span><br><span class="line">pid:[4026532469]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再创建新的pid namespace</span></span><br><span class="line">root@container001:~# unshare --uts --pid --mount --fork --mount-proc /bin/bash</span><br><span class="line">root@container001:~# hostname container002</span><br><span class="line">root@container001:~# exec bash</span><br><span class="line">root@container002:~# readlink /proc/$$/ns/pid</span><br><span class="line">pid:[4026532472]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再创建新的pid namespace</span></span><br><span class="line">root@container002:~# unshare --uts --pid --mount --fork --mount-proc /bin/bash</span><br><span class="line">root@container002:~# hostname container003</span><br><span class="line">root@container002:~# exec bash</span><br><span class="line">root@container003:~# readlink /proc/$$/ns/pid</span><br><span class="line">pid:[4026532475]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">目前namespace container003里面就一个bash进程</span></span><br><span class="line">root@container003:~# pstree -p</span><br><span class="line">bash(1)───pstree(22)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样我们就有了三层pid namespace，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">他们的父子关系为container001-&gt;container002-&gt;container003</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第二个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在最外层的namespace中查看上面新创建的三个namespace中的bash进程</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从这里可以看出，这里显示的bash进程的PID和上面container003里看到的bash(1)不一样</span></span><br><span class="line">dev@ubuntu:~$ pstree -pl|grep bash|grep unshare</span><br><span class="line">|-sshd(955)-+-sshd(17810)---sshd(17891)---bash(17892)---sudo(31814)--</span><br><span class="line">-unshare(31815)---bash(31816)---unshare(31842)---bash(31843)--</span><br><span class="line">-unshare(31864)---bash(31865)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">各个unshare进程的子bash进程分别属于上面的三个pid namespace</span></span><br><span class="line">dev@ubuntu:~$ sudo readlink /proc/31816/ns/pid</span><br><span class="line">pid:[4026532469]</span><br><span class="line">dev@ubuntu:~$ sudo readlink /proc/31843/ns/pid</span><br><span class="line">pid:[4026532472]</span><br><span class="line">dev@ubuntu:~$ sudo readlink /proc/31865/ns/pid</span><br><span class="line">pid:[4026532475]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PID在各个namespace里的映射关系可以通过/proc/[pid]/status查看到</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里31865是在最外面namespace中看到的pid</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">45，23，1分别是在container001，container002和container003中的pid</span></span><br><span class="line">dev@ubuntu:~$ grep pid /proc/31865/status</span><br><span class="line">NSpid:  31865   45     23      1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个新的bash并加入container002</span></span><br><span class="line">dev@ubuntu:~$ sudo nsenter --uts --mount --pid -t 31843 /bin/bash</span><br><span class="line">root@container002:/#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里bash（23）就是container003里面的pid 1对应的bash</span></span><br><span class="line">root@container002:/# pstree -p</span><br><span class="line">bash(1)───unshare(22)───bash(23)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">unshare(22)属于container002</span></span><br><span class="line">root@container002:/# readlink /proc/22/ns/pid</span><br><span class="line">pid:[4026532472]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bash（23）属于container003</span></span><br><span class="line">root@container002:/# readlink /proc/23/ns/pid</span><br><span class="line">pid:[4026532475]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么上面pstree的结果里面没看到nsenter加进来的bash呢？</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过ps命令我们发现，我们新加进来的那个/bin/bash的ppid是0，难怪pstree里面显示不出来</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从这里可以看出，跟最外层namespace不一样的地方就是，这里可以有多个进程的ppid为0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从这里的TTY也可以看出哪些命令是在哪些窗口执行的，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pts/0对应第一个shell窗口，pts/1对应第二个shell窗口</span></span><br><span class="line">root@container002:/# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 04:39 pts/0    00:00:00 bash</span><br><span class="line">root        22     1  0 04:39 pts/0    00:00:00 unshare --uts --pid --mount --fork --mount-proc /bin/bash</span><br><span class="line">root        23    22  0 04:39 pts/0    00:00:00 bash</span><br><span class="line">root        46     0  0 04:52 pts/1    00:00:00 /bin/bash</span><br><span class="line">root        59    46  0 04:53 pts/1    00:00:00 ps -ef</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第三个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个新的bash并加入container001</span></span><br><span class="line">dev@ubuntu:~$ sudo nsenter --uts --mount --pid -t 31816 /bin/bash</span><br><span class="line">root@container001:/#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过pstree和ps -ef我们可看到所有三个namespace中的进程及他们的关系</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bash(1)───unshare(22)属于container001</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bash(23)───unshare(44)属于container002</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bash(45)属于container003，而68和84两个进程分别是上面两次通过nsenter加进来的bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同上面ps的结果比较我们可以看出，同样的进程在不同的namespace里面拥有不同的PID</span></span><br><span class="line">root@container001:/# pstree -pl</span><br><span class="line">bash(1)───unshare(22)───bash(23)───unshare(44)───bash(45)</span><br><span class="line">root@container001:/# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 04:37 pts/0    00:00:00 bash</span><br><span class="line">root        22     1  0 04:39 pts/0    00:00:00 unshare --uts --pid --mount --fork --mount-proc /bin/bash</span><br><span class="line">root        23    22  0 04:39 pts/0    00:00:00 bash</span><br><span class="line">root        44    23  0 04:39 pts/0    00:00:00 unshare --uts --pid --mount --fork --mount-proc /bin/bash</span><br><span class="line">root        45    44  0 04:39 pts/0    00:00:00 bash</span><br><span class="line">root        68     0  0 04:52 pts/1    00:00:00 /bin/bash</span><br><span class="line">root        84     0  0 05:00 pts/2    00:00:00 /bin/bash</span><br><span class="line">root        95    84  0 05:00 pts/2    00:00:00 ps -ef</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发送信号给contain002中的bash</span></span><br><span class="line">root@container001:/# kill 68</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第二个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到第二个窗口，发现bash已经被<span class="built_in">kill</span>掉了，说明父namespace是可以发信号给子namespace中的进程的</span></span><br><span class="line">root@container002:/# exit</span><br><span class="line">dev@ubuntu:~$</span><br></pre></td></tr></table></figure>

<h2 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h2><p>Mount namespace用来隔离文件系统的挂载点，使不同的namespace之间不会受影响，这样用户可以构建容器自己的文件系统。</p>
<p>当前进程所在mount namespace里的所有挂载信息可以在&#x2F;proc&#x2F;[pid]&#x2F;mounts、&#x2F;proc&#x2F;[pid]&#x2F;mountinfo和&#x2F;proc&#x2F;[pid]&#x2F;mountstats里面找到。</p>
<p>Mount namespaces是第一个被加入Linux的namespace，由于当时没想到还会引入其它的namespace，所以取名为CLONE_NEWNS，而没有叫CLONE_NEWMOUNT。</p>
<p>每个mount namespace都拥有一份自己的挂载点列表，当用clone或者unshare函数创建新的mount namespace时，新创建的namespace将拷贝一份老namespace里的挂载点列表，但从这之后，他们就没有关系了，通过mount和umount增加和删除各自namespace里面的挂载点都不会相互影响。</p>
<h2 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h2><p>User namespace用来隔离user权限相关的Linux资源，包括user IDs and group IDs，keys , 和capabilities.</p>
<p>user namespace可以嵌套（目前内核控制最多32层），除了系统默认的user namespace外，所有的user namespace都有一个父user namespace，每个user namespace都可以有零到多个子user namespace。 当在一个进程中调用unshare或者clone创建新的user namespace时，当前进程原来所在的user namespace为父user namespace，新的user namespace为子user namespace。</p>
<p>在不同的user namespace中，同样一个用户的user ID 和group ID可以不一样，换句话说，一个用户可以在父user namespace中是普通用户，在子user namespace中是超级用户（超级用户只相对于子user namespace所拥有的资源，无法访问其他user namespace中需要超级用户才能访问资源）。</p>
<h3 id="创建user-namespace"><a href="#创建user-namespace" class="headerlink" title="创建user namespace"></a>创建user namespace</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先记录下目前的<span class="built_in">id</span>，gid和user namespace</span></span><br><span class="line">dev@ubuntu:~$ id</span><br><span class="line">uid=1000(dev) gid=1000(dev) groups=1000(dev),4(adm),24(cdrom),27(sudo)</span><br><span class="line">dev@ubuntu:~$ readlink /proc/$$/ns/user</span><br><span class="line">user:[4026531837]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建新的user namespace</span></span><br><span class="line">dev@ubuntu:~$ unshare --user /bin/bash</span><br><span class="line">nobody@ubuntu:~$ readlink /proc/$$/ns/user</span><br><span class="line">user:[4026532464]</span><br><span class="line">nobody@ubuntu:~$ id</span><br><span class="line">uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)</span><br></pre></td></tr></table></figure>

<p>很奇怪，为什么上面例子中显示的用户名是nobody，它的id和gid都是65534？</p>
<p>这是因为我们还没有映射父user namespace的user ID和group ID到子user namespace中来，这一步是必须的，因为这样系统才能控制一个user namespace里的用户在其他user namespace中的权限。（比如给其他user namespace中的进程发送信号，或者访问属于其他user namespace挂载的文件）</p>
<p>如果没有映射的话，当在新的user namespace中用getuid()和getgid()获取user id和group id时，系统将返回文件&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;overflowuid中定义的user ID以及proc&#x2F;sys&#x2F;kernel&#x2F;overflowgid中定义的group ID，它们的默认值都是65534。也就是说如果没有指定映射关系的话，会默认映射到ID65534。</p>
<p>下面看看这个user能干些什么?</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">ls</span>的结果显示/root目录属于nobody</span></span><br><span class="line">nobody@ubuntu:~$ ls -l /|grep root</span><br><span class="line">drwx------   3 nobody nogroup  4096 7月   8 18:39 root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但是当前的nobody账号访问不了，说明这两个nobody不是一个ID，他们之间没有映射关系</span></span><br><span class="line">nobody@ubuntu:~$ ls /root</span><br><span class="line">ls: cannot open directory &#x27;/root&#x27;: Permission denied</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里显示/home/dev目录属于nobody</span></span><br><span class="line">nobody@ubuntu:~$ ls -l /home/</span><br><span class="line">drwxr-xr-x 11 nobody nogroup 4096 7月   8 18:40 dev</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">touch</span>成功，说明虽然没有显式的映射ID，但还是能访问父user namespace里dev账号拥有的资源</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明他们背后还是有映射关系</span></span><br><span class="line">nobody@ubuntu:~$ touch /home/dev/temp01</span><br><span class="line">nobody@ubuntu:~$</span><br></pre></td></tr></table></figure>

<h3 id="映射user-ID和group-ID"><a href="#映射user-ID和group-ID" class="headerlink" title="映射user ID和group ID"></a>映射user ID和group ID</h3><p>通常情况下，创建新的user namespace后，第一件事就是映射user和group ID. 映射ID的方法是添加配置到&#x2F;proc&#x2F;PID&#x2F;uid_map和&#x2F;proc&#x2F;PID&#x2F;gid_map（这里的PID是新user namespace中的进程ID，刚开始时这两个文件都是空的）.<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051638835.png" alt="在这里插入图片描述"><br>这两个文件里面的配置格式如下（可以有多条)：</p>
<blockquote>
<p>ID-inside-ns   ID-outside-ns   length<br>举个例子, 0 1000 256这条配置就表示父user namespace中的1000<del>1256映射到新user namespace中的0</del>256。<br>系统默认的user namespace没有父user namespace，但为了保持一致，kernel提供了一个虚拟的uid和gid map文件，看起来是这样子的:<br>dev@ubuntu:~$ cat &#x2F;proc&#x2F;$$&#x2F;uid_map<br>0 0 4294967295</p>
</blockquote>
<p>那么谁可以向这个文件中写配置呢？</p>
<p>&#x2F;proc&#x2F;PID&#x2F;uid_map和&#x2F;proc&#x2F;PID&#x2F;gid_map的拥有者是创建新user namespace的这个user，所以和这个user在一个user namespace的root账号可以写。但这个user自己有没有写map文件权限还要看它有没有CAP_SETUID和CAP_SETGID的capability。</p>
<blockquote>
<p>注意：只能向map文件写一次数据，但可以一次写多条，并且最多只能5条</p>
</blockquote>
<p>原来的Linux就分root和非root，很多操作只能root完成，比如修改一个文件的owner，后来Linux将root的一些权限分解了，变成了各种capability，只要拥有了相应的capability，就能做相应的操作，不需要root账户的权限。</p>
<p>下面我们来看看如何用dev账号映射uid和gid</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取当前bash的pid</span></span><br><span class="line">nobody@ubuntu:~$ echo $$</span><br><span class="line">24126</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第二个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dev是map文件的owner</span></span><br><span class="line">dev@ubuntu:~$ ls -l /proc/24126/uid_map /proc/24126/gid_map</span><br><span class="line">-rw-r--r-- 1 dev dev 0 7月  24 23:11 /proc/24126/gid_map</span><br><span class="line">-rw-r--r-- 1 dev dev 0 7月  24 23:11 /proc/24126/uid_map</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但还是没有权限写这个文件</span></span><br><span class="line">dev@ubuntu:~$ echo &#x27;0 1000 100&#x27; &gt; /proc/24126/uid_map</span><br><span class="line">bash: echo: write error: Operation not permitted</span><br><span class="line">dev@ubuntu:~$ echo &#x27;0 1000 100&#x27; &gt; /proc/24126/gid_map</span><br><span class="line">bash: echo: write error: Operation not permitted</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前用户运行的bash进程没有CAP_SETUID和CAP_SETGID的权限</span></span><br><span class="line">dev@ubuntu:~$ cat /proc/$$/status | egrep &#x27;Cap(Inh|Prm|Eff)&#x27;</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 0000000000000000</span><br><span class="line">CapEff: 0000000000000000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为/binb/bash设置capability，</span></span><br><span class="line">dev@ubuntu:~$ sudo setcap cap_setgid,cap_setuid+ep /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新加载bash以后我们看到相应的capability已经有了</span></span><br><span class="line">dev@ubuntu:~$ exec bash</span><br><span class="line">dev@ubuntu:~$ cat /proc/$$/status | egrep &#x27;Cap(Inh|Prm|Eff)&#x27;</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 00000000000000c0</span><br><span class="line">CapEff: 00000000000000c0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再试一次写map文件，成功了</span></span><br><span class="line">dev@ubuntu:~$ echo &#x27;0 1000 100&#x27; &gt; /proc/24126/uid_map</span><br><span class="line">dev@ubuntu:~$ echo &#x27;0 1000 100&#x27; &gt; /proc/24126/gid_map</span><br><span class="line">dev@ubuntu:~$</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再写一次就失败了，因为这个文件只能写一次</span></span><br><span class="line">dev@ubuntu:~$ echo &#x27;0 1000 100&#x27; &gt; /proc/24126/uid_map</span><br><span class="line">bash: echo: write error: Operation not permitted</span><br><span class="line">dev@ubuntu:~$ echo &#x27;0 1000 100&#x27; &gt; /proc/24126/gid_map</span><br><span class="line">bash: echo: write error: Operation not permitted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后续测试不需要CAP_SETUID了，将/bin/bash的capability恢复到原来的设置</span></span><br><span class="line">dev@ubuntu:~$ sudo setcap cap_setgid,cap_setuid-ep /bin/bash</span><br><span class="line">dev@ubuntu:~$ getcap /bin/bash</span><br><span class="line">/bin/bash =</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到第一个窗口，<span class="built_in">id</span>已经变成0了，说明映射成功</span></span><br><span class="line">nobody@ubuntu:~$ id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),65534(nogroup)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第二个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到第二个窗口，确认map文件的owner，这里24126是新user namespace中的bash</span></span><br><span class="line">dev@ubuntu:~$ ls -l /proc/24126/</span><br><span class="line">......</span><br><span class="line">-rw-r--r-- 1 dev dev 0 7月  24 23:13 gid_map</span><br><span class="line">dr-x--x--x 2 dev dev 0 7月  24 23:10 ns</span><br><span class="line">-rw-r--r-- 1 dev dev 0 7月  24 23:13 uid_map</span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新加载bash，提示有root权限了</span></span><br><span class="line">nobody@ubuntu:~$ exec bash</span><br><span class="line">root@ubuntu:~#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0000003fffffffff表示当前运行的bash拥有所有的capability</span></span><br><span class="line">root@ubuntu:~# cat /proc/$$/status | egrep &#x27;Cap(Inh|Prm|Eff)&#x27;</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 0000003fffffffff</span><br><span class="line">CapEff: 0000003fffffffff</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第二个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到第二个窗口，发现owner已经变了，变成了root</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">目前还不清楚为什么有这样的机制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本内核并无该问题</span></span><br><span class="line">dev@ubuntu:~$ ls -l /proc/24126/</span><br><span class="line">......</span><br><span class="line">-rw-r--r-- 1 root root 0 7月  24 23:13 gid_map</span><br><span class="line">dr-x--x--x 2 root root 0 7月  24 23:10 ns</span><br><span class="line">-rw-r--r-- 1 root root 0 7月  24 23:13 uid_map</span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">虽然不能看目录里有哪些文件，但是可以读里面文件的内容</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本内核并无该问题</span></span><br><span class="line">dev@ubuntu:~$ ls -l /proc/24126/ns</span><br><span class="line">ls: cannot open directory &#x27;/proc/24126/ns&#x27;: Permission denied</span><br><span class="line">dev@ubuntu:~$ readlink /proc/24126/ns/user</span><br><span class="line">user:[4026532464]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">和第二个窗口一样的结果</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新版本内核并无该问题</span></span><br><span class="line">root@ubuntu:~# ls -l /proc/24126/ns</span><br><span class="line">ls: cannot open directory &#x27;/proc/24126/ns&#x27;: Permission denied</span><br><span class="line">root@ubuntu:~# readlink /proc/24126/ns/user</span><br><span class="line">user:[4026532464]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">仍然不能访问/root目录，因为他的拥有着是nobody</span></span><br><span class="line">root@ubuntu:~# ls -l /|grep root</span><br><span class="line">drwx------   3 nobody nogroup  4096 7月   8 18:39 root</span><br><span class="line">root@ubuntu:~# ls /root</span><br><span class="line">ls: cannot open directory &#x27;/root&#x27;: Permission denied</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对于原来/home/dev下的内容，显示的owner已经映射过来了，由dev变成了新namespace中的root，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前root用户可以访问他里面的内容</span></span><br><span class="line">root@ubuntu:~# ls -l /home</span><br><span class="line">drwxr-xr-x 8 root root 4096 7月  21 18:35 dev</span><br><span class="line">root@ubuntu:~# touch /home/dev/temp01</span><br><span class="line">root@ubuntu:~#</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">试试设置主机名称</span></span><br><span class="line">root@ubuntu:~# hostname container001</span><br><span class="line">hostname: you must be root to change the host name</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改失败，说明这个新user namespace中的root账号在父user namespace里面不好使</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这也正是user namespace所期望达到的效果，当访问其他user namespace里的资源时，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是以其他user namespace中的相应账号的权限来执行的，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比如这里root对应父user namespace的账号是dev，所以改不了系统的hostname</span></span><br></pre></td></tr></table></figure>

<p>那是不是把系统默认user namespace的root账号映射到新的user namespace中，新user namespace的root就可以修改默认user namespace中的hostname呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第三个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新打开一个窗口</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里不再手动映射uid和gid，而是利用unshare命令的-r参数来帮我们完成映射，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定-r参数后，unshare将会帮助我们将当前运行unshare的账号映射成新user namesapce的root账号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里用了<span class="built_in">sudo</span>，目的是让root账号来运行unshare命令，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样就将外面的root账号映射成新user namespace的root账号</span></span><br><span class="line">dev@ubuntu:~$ sudo unshare --user -r /bin/bash</span><br><span class="line">root@ubuntu:~# id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">确认是用root映射root</span></span><br><span class="line">root@ubuntu:~# echo $$</span><br><span class="line">24283</span><br><span class="line">root@ubuntu:~# cat /proc/24283/uid_map</span><br><span class="line">         0          0          1</span><br><span class="line">root@ubuntu:~# cat /proc/24283/gid_map</span><br><span class="line">         0          0          1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以访问/root目录下的东西，但无法操作/home/dev/下的文件</span></span><br><span class="line">root@ubuntu:~# ls -l / |grep root$</span><br><span class="line">drwx------   6 root root  4096 8月  14 23:11 root</span><br><span class="line">root@ubuntu:~# touch /root/temp01</span><br><span class="line">root@ubuntu:~# ls -l /home</span><br><span class="line">drwxr-xr-x 11 nobody nogroup 4096 8月  14 23:13 dev</span><br><span class="line">root@ubuntu:~# touch /home/dev/temp01</span><br><span class="line">touch: cannot touch &#x27;/home/dev/temp01&#x27;: Permission denied</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">尝试修改hostname，还是失败</span></span><br><span class="line">root@ubuntu:~# hostname container001</span><br><span class="line">hostname: you must be root to change the host name</span><br></pre></td></tr></table></figure>

<p>上面的例子中虽然是将root账号映射到了新user namespace的root账号上，但修改hostname、访问&#x2F;home&#x2F;dev下的文件依然失败，那是因为不管怎么映射，当用子user namespace的账号访问父user namespace的资源的时候，它启动的进程的capability都为空，所以这里子user namespace的root账号到父namespace中就相当于一个普通的账号。</p>
<h2 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h2><p>network namespace用来隔离网络设备, IP地址, 端口等. 每个namespace将会有自己独立的网络栈，路由表，防火墙规则，socket等。</p>
<p>每个新的network namespace默认有一个本地环回接口，除了lo接口外，所有的其他网络设备（物理&#x2F;虚拟网络接口，网桥等）只能属于一个network namespace。每个socket也只能属于一个network namespace。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>同一个主机内的不同 namespace 之间的通信，以及 namespace 和主机的通信，需要借助网桥和 veth-pair 实现。<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639300.png" alt="在这里插入图片描述"></p>
<ul>
<li>创建命名空间</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br></pre></td></tr></table></figure>

<ul>
<li>创建网桥</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link add name bridge0 type bridge</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 veth-pair</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link add veth1 type veth peer name vethb1</span><br><span class="line">ip link add veth2 type veth peer name vethb2</span><br></pre></td></tr></table></figure>

<ul>
<li>将 veth 的一端放在网桥上</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link set vethb1 master bridge0</span><br><span class="line">ip link set vethb2 master bridge0</span><br></pre></td></tr></table></figure>

<ul>
<li>将 veth 另一端放在 namespace</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link set veth1 netns ns1</span><br><span class="line">ip link set veth2 netns ns2</span><br></pre></td></tr></table></figure>

<ul>
<li>给网络设备配置 ip 地址</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip addr add 10.1.1.2/24 dev veth1</span><br><span class="line">ip netns exec ns2 ip addr add 10.1.1.3/24 dev veth2</span><br><span class="line">ip addr add 10.1.1.1/24 dev bridge0</span><br></pre></td></tr></table></figure>

<ul>
<li>启动网络设备</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link set bridge0 up</span><br><span class="line">ip link set vethb1  up</span><br><span class="line">ip link set vethb2  up</span><br><span class="line">ip netns exec ns1 ip link set veth1 up</span><br><span class="line">ip netns exec ns2 ip link set veth2 up</span><br></pre></td></tr></table></figure>

<p>相互间可以ping通<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639442.png" alt="在这里插入图片描述"></p>
<h1 id="容器支撑技术-cgroup"><a href="#容器支撑技术-cgroup" class="headerlink" title="容器支撑技术-cgroup"></a>容器支撑技术-cgroup</h1><p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639021.png" alt="在这里插入图片描述"></p>
<h2 id="cgroup的作用"><a href="#cgroup的作用" class="headerlink" title="cgroup的作用"></a>cgroup的作用</h2><p>cgroup代表control group，group这个集合的主要目的在于控制资源的使用：多个进程作为一个整体享有资源的配额（quota），同时接受资源的限制。<br>cgroup提供了对一组进程及将来的子进程的资源限制的能力。</p>
<h2 id="cgroup组成"><a href="#cgroup组成" class="headerlink" title="cgroup组成"></a>cgroup组成</h2><p>Cgroups主要由task,cgroup,subsystem及hierarchy构成。下面分别介绍下各自的概念。</p>
<ul>
<li>Task : 在Cgroups中，task就是系统的一个进程。</li>
<li>Cgroup : Cgroups中的资源控制都以cgroup为单位实现的。cgroup表示按照某种资源控制标准划分而成的任务组，包含一个或多个Subsystems。一个任务可以加入某个cgroup，也可以从某个cgroup迁移到另外一个cgroup。</li>
<li>Subsystem : Cgroups中的subsystem就是一个资源调度控制器（Resource Controller）。比如CPU子系统可以控制CPU时间分配，内存子系统可以限制cgroup内存使用量。</li>
<li>Hierarchy : hierarchy由一系列cgroup以一个树状结构排列而成，每个hierarchy通过绑定对应的subsystem进行资源调度。hierarchy中的cgroup节点可以包含零或多个子节点，子节点继承父节点的属性。整个系统可以有多个hierarchy。</li>
</ul>
<h2 id="cgroup规则"><a href="#cgroup规则" class="headerlink" title="cgroup规则"></a>cgroup规则</h2><p>  主要介绍Subsystems, Hierarchies,Control Group和Tasks之间组织结构和规则：</p>
<p><strong>规则一：</strong><br>       同一个hierarchy能够附加一个或多个subsystem。如 cpu 和 memory subsystems(或者任意多个subsystems)附加到同一个hierarchy。</p>
<p><strong>规则二：</strong><br>       一个 subsystem 可以附加到多个 hierarchy，当且仅当这些 hierarchy 只有这唯一一个 subsystem。即某个hierarchy（hierarchy A）中的subsystem（如CPU）不能附加到已经附加了其他subsystem的hierarchy（如hierarchy B）中。也就是说已经附加在某个 hierarchy 上的 subsystem 不能附加到其他含有别的 subsystem 的 hierarchy 上。</p>
<p><strong>规则三：</strong><br>       系统每次新建一个hierarchy时，该系统上的所有task默认构成了这个新建的hierarchy的初始化cgroup，这个cgroup也称为root cgroup。对于你创建的每个hierarchy，task只能存在于其中一个cgroup中，即一个task不能存在于同一个hierarchy的不同cgroup中，但是一个task可以存在在不同hierarchy中的多个cgroup中。如果操作时把一个task添加到同一个hierarchy中的另一个cgroup中，则会从第一个cgroup中移除<br>如：<br>cpu 和 memory subsystem被附加到 cpu_mem_cg 的hierarchy。而 net_cls subsystem被附加到 net_cls hierarchy。并且httpd进程被同时加到了 cpu_mem_cg hierarchy的 cg1 cgroup中和 net hierarchy的 cg2 cgroup中。并通过两个hierarchy的subsystem分别对httpd进程进行cpu,memory及网络带宽的限制。</p>
<p><strong>规则四：</strong><br>       进程（task）在 fork 自身时创建的子任务（child task）默认与原 task 在同一个 cgroup 中，但是 child task 允许被移动到不同的 cgroup 中。即 fork 完成后，父子进程间是完全独立的。</p>
<h2 id="cgroup子系统"><a href="#cgroup子系统" class="headerlink" title="cgroup子系统"></a>cgroup子系统</h2><p>目前Linux支持下面12种subsystem</p>
<ul>
<li><p>cpu (since Linux 2.6.24; CONFIG_CGROUP_SCHED)<br>用来限制cgroup的CPU使用率。</p>
</li>
<li><p>cpuacct (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)<br>统计cgroup的CPU的使用率。</p>
</li>
<li><p>cpuset (since Linux 2.6.24; CONFIG_CPUSETS)<br>绑定cgroup到指定CPUs和NUMA节点。</p>
</li>
<li><p>memory (since Linux 2.6.25; CONFIG_MEMCG)<br>统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。</p>
</li>
<li><p>devices (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)<br>限制cgroup创建(mknod)和访问设备的权限。</p>
</li>
<li><p>freezer (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)<br>suspend和restore一个cgroup中的所有进程。</p>
</li>
<li><p>net_cls (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)<br>将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。</p>
</li>
<li><p>blkio (since Linux 2.6.33; CONFIG_BLK_CGROUP)<br>限制cgroup访问块设备的IO速度。</p>
</li>
<li><p>perf_event (since Linux 2.6.39; CONFIG_CGROUP_PERF)<br>对cgroup进行性能监控</p>
</li>
<li><p>net_prio (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)<br>针对每个网络接口设置cgroup的访问优先级。</p>
</li>
<li><p>hugetlb (since Linux 3.5; CONFIG_CGROUP_HUGETLB)<br>限制cgroup的huge pages的使用量。</p>
</li>
<li><p>pids (since Linux 4.3; CONFIG_CGROUP_PIDS)<br>限制一个cgroup及其子孙cgroup中的总进程数。</p>
</li>
</ul>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>systemd已经帮我们将memory绑定到了&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dev@dev:~$ mount|grep memory</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br></pre></td></tr></table></figure>

<h3 id="创建子cgroup"><a href="#创建子cgroup" class="headerlink" title="创建子cgroup"></a>创建子cgroup</h3><p>在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory下创建一个子目录即创建了一个子cgroup</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line">dev@dev:~$ cd /sys/fs/cgroup/memory</span><br><span class="line">dev@dev:/sys/fs/cgroup/memory$ sudo mkdir test</span><br><span class="line">dev@dev:/sys/fs/cgroup/memory$ ls test</span><br><span class="line">cgroup.clone_children  memory.kmem.failcnt             memory.kmem.tcp.limit_in_bytes      memory.max_usage_in_bytes        memory.soft_limit_in_bytes  notify_on_release</span><br><span class="line">cgroup.event_control   memory.kmem.limit_in_bytes      memory.kmem.tcp.max_usage_in_bytes  memory.move_charge_at_immigrate  memory.stat                 tasks</span><br><span class="line">cgroup.procs           memory.kmem.max_usage_in_bytes  memory.kmem.tcp.usage_in_bytes      memory.numa_stat                 memory.swappiness</span><br><span class="line">memory.failcnt         memory.kmem.slabinfo            memory.kmem.usage_in_bytes          memory.oom_control               memory.usage_in_bytes</span><br><span class="line">memory.force_empty     memory.kmem.tcp.failcnt         memory.limit_in_bytes               memory.pressure_level            memory.use_hierarchy</span><br></pre></td></tr></table></figure>

<p>从上面ls的输出可以看出，除了每个cgroup都有的那几个文件外，和memory相关的文件还不少，每个文件的作用如下：&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cgroup.event_control       #用于eventfd的接口</span><br><span class="line">memory.usage_in_bytes      #显示当前已用的内存</span><br><span class="line">memory.limit_in_bytes      #设置/显示当前限制的内存额度</span><br><span class="line">memory.failcnt             #显示内存使用量达到限制值的次数</span><br><span class="line">memory.max_usage_in_bytes  #历史内存最大使用量</span><br><span class="line">memory.soft_limit_in_bytes #设置/显示当前限制的内存软额度</span><br><span class="line">memory.stat                #显示当前cgroup的内存使用情况</span><br><span class="line">memory.use_hierarchy       #设置/显示是否将子cgroup的内存使用情况统计到当前cgroup里面</span><br><span class="line">memory.force_empty         #触发系统立即尽可能的回收当前cgroup中可以回收的内存</span><br><span class="line">memory.pressure_level      #设置内存压力的通知事件，配合cgroup.event_control一起使用</span><br><span class="line">memory.swappiness          #设置和显示当前的swappiness</span><br><span class="line">memory.move_charge_at_immigrate #设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去</span><br><span class="line">memory.oom_control         #设置/显示oom controls相关的配置</span><br><span class="line">memory.numa_stat           #显示numa相关的内存</span><br></pre></td></tr></table></figure>

<h3 id="添加进程"><a href="#添加进程" class="headerlink" title="添加进程"></a>添加进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第二个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新打开一个shell窗口，避免相互影响</span></span><br><span class="line">dev@dev:~$ cd /sys/fs/cgroup/memory/test/</span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ echo $$</span><br><span class="line">4589</span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ sudo sh -c &quot;echo $$ &gt;&gt; cgroup.procs&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行top命令，这样这个cgroup消耗的内存会多点，便于观察</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ top</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后续操作不再在这个窗口进行，避免在这个bash中运行进程影响cgropu里面的进程数及相关统计</span></span><br></pre></td></tr></table></figure>

<h3 id="设置限额"><a href="#设置限额" class="headerlink" title="设置限额"></a>设置限额</h3><p>设置限额很简单，写文件memory.limit_in_bytes就可以了，请仔细看示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到第一个shell窗口</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory$ cd test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里两个进程<span class="built_in">id</span>分别时第二个窗口的bash和top进程</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat cgroup.procs</span><br><span class="line">4589</span><br><span class="line">4664</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开始设置之前，看看当前使用的内存数量，这里的单位是字节</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat memory.usage_in_bytes</span><br><span class="line">835584</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置1M的限额</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ sudo sh -c &quot;echo 1M &gt; memory.limit_in_bytes&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置完之后记得要查看一下这个文件，因为内核要考虑页对齐, 所以生效的数量不一定完全等于设置的数量</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat memory.limit_in_bytes</span><br><span class="line">1048576</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不再需要限制这个cgroup，写-1到文件memory.limit_in_bytes即可</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ sudo sh -c &quot;echo -1 &gt; memory.limit_in_bytes&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这时可以看到<span class="built_in">limit</span>被设置成了一个很大的数字</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat memory.limit_in_bytes</span><br><span class="line">9223372036854771712</span><br></pre></td></tr></table></figure>

<p>如果设置的限额比当前已经使用的内存少呢？如上面显示当前bash用了800多k，如果我设置limit为400K会怎么样？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先用free看下当前swap被用了多少</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:         500192       45000       34200        2644      420992      424020</span><br><span class="line">Swap:        524284          16      524268</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置内存限额为400K</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ sudo sh -c &quot;echo 400K &gt; memory.limit_in_bytes&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再看当前cgroup的内存使用情况</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发现内存占用少了很多，刚好在400K以内，原来用的那些内存都去哪了呢？</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat memory.usage_in_bytes</span><br><span class="line">401408</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再看swap空间的占用情况，和刚开始比，多了500-16=384K，说明内存中的数据被移到了swap上</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:         500192       43324       35132        2644      421736      425688</span><br><span class="line">Swap:        524284         500      523784</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个时候再来看failcnt，发现有453次之多(隔几秒再看这个文件，发现次数在增长)</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat memory.failcnt</span><br><span class="line">453</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再看看memory.stat（这里只显示部分内容），发现物理内存用了400K，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但有很多pgmajfault以及pgpgin和pgpgout，说明发生了很多的swap <span class="keyword">in</span>和swap out</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat memory.stat</span><br><span class="line">rss 409600</span><br><span class="line">total_pgpgin 4166</span><br><span class="line">total_pgpgout 4066</span><br><span class="line">total_pgfault 7558</span><br><span class="line">total_pgmajfault 419</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从上面的结果可以看出，当物理内存不够时，就会触发memory.failcnt里面的数量加1，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但进程不会被<span class="built_in">kill</span>掉，那是因为内核会尝试将物理内存中的数据移动到swap空间中，从而让内存分配成功</span></span><br></pre></td></tr></table></figure>

<p>如果设置的限额过小，就算swap out部分内存后还是不够会怎么样？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------第一个shell窗口----------------------</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ sudo sh -c &quot;echo 1K &gt; memory.limit_in_bytes&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进程已经不在了（第二个窗口已经挂掉了）</span></span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat cgroup.procs</span><br><span class="line">dev@dev:/sys/fs/cgroup/memory/test$ cat memory.usage_in_bytes</span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从这里的结果可以看出，第二个窗口的bash和top都被<span class="built_in">kill</span>掉了</span></span><br></pre></td></tr></table></figure>

<p>从上面的这些测试可以看出，一旦设置了内存限制，将立即生效，并且当物理内存使用量达到limit的时候，memory.failcnt的内容会加1，但这时进程不一定就会被kill掉，内核会尽量将物理内存中的数据移到swap空间上去，如果实在是没办法移动了（设置的limit过小，或者swap空间不足），默认情况下，就会kill掉cgroup里面继续申请内存的进程。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch-using_control_groups">红帽cgroup资料</a></p>
<h1 id="docker支撑技术-Union-FS"><a href="#docker支撑技术-Union-FS" class="headerlink" title="docker支撑技术-Union FS"></a>docker支撑技术-Union FS</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t aufs -o br=./Branch-0:./Branch-1:./Branch-2 none ./MountPoint</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-t aufs： 指定挂载类型为aufs</li>
<li>-o br&#x3D;.&#x2F;Branch-0:.&#x2F;Branch-1:.&#x2F;Branch-2： 表示将当前目录下的Branch-0，Branch-1，Branch-2三个文件夹联合到一起</li>
<li>none：aufs不需要设备，只依赖于-o br指定的文件夹，所以这里填none即可</li>
<li>&#x2F;MountPoint：表示将最后联合的结果挂载到当前的MountPoint目录下，然后我们就可以往这个目录里面读写文件了<br>假设Branch-0里面有文件001.txt、003.txt，Branch-1里面有文件001.txt、003.txt、004.txt，Branch-2里面有文件002.txt、003.txt。</li>
</ul>
<p>mount完成后，得到的结果将会如下图所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">              /*001.txt(b0)表示Branch-0的001.txt文件，其它的以此类推*/</span><br><span class="line">           +-------------+-------------+-------------+-------------+</span><br><span class="line">MountPoint | 001.txt(b0) | 002.txt(b2) | 003.txt(b0) | 004.txt(b1) |    </span><br><span class="line">           +-------------+-------------+-------------+-------------+</span><br><span class="line">                  ↑             ↑             ↑             ↑</span><br><span class="line">                  |             |             |             |</span><br><span class="line">           +-------------+-------------+-------------+-------------+</span><br><span class="line">Branch-0   |   001.txt   |             |   003.txt   |             |</span><br><span class="line">           +-------------+-------------+-------------+-------------+</span><br><span class="line">Branch-1   |   001.txt   |             |   003.txt   |   004.txt   |</span><br><span class="line">           +-------------+-------------+-------------+-------------+</span><br><span class="line">Branch-2   |             |   002.txt   |   003.txt   |             |</span><br><span class="line">           +-------------+-------------+-------------+-------------+</span><br></pre></td></tr></table></figure>

<p>联合之后，在MountPoint下将会看到四个文件，分别是Branch-0下的001.txt、003.txt，Branch-1下的04.txt，以及Branch-2下的002.txt。</p>
<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时的库、环境变量和配置文件。</p>
<h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><blockquote>
<p>Unions （联合文件系统）</p>
</blockquote>
<p>Unions （联合文件系统）：Unions 是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639291.png" alt="在这里插入图片描述"></p>
<p><strong>特性：</strong>一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。  </p>
<h2 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h2><blockquote>
<p>镜像为什么会产生分层的结构</p>
</blockquote>
<p>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享 。</p>
<p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或添加新的内容时，就会在当前镜像层之上，创建新的镜像层。<br>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639986.png" alt="请添加图片描述"><br>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了<br>一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639430.png" alt="请添加图片描述"><br>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件<br>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639232.png" alt="请添加图片描述"><br>这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。<br>Docker通过存储引擎来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。<br>Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图。  </p>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051639385.png" alt="请添加图片描述"><br>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！<br>这一层就是我们通常说的容器层，容器之下的都叫镜像层！  </p>
<h2 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h2><p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640263.png" alt="请添加图片描述"></p>
<h1 id="docker镜像管理"><a href="#docker镜像管理" class="headerlink" title="docker镜像管理"></a>docker镜像管理</h1><ul>
<li>registry</li>
</ul>
<p>镜像仓库，用户可以构建自己的私有仓库</p>
<ul>
<li>repository</li>
</ul>
<p>repository是一个镜像集合，其中包含多个版本的镜像，使用标签可以进行版本区分。</p>
<ul>
<li>image</li>
</ul>
<p>image用来存储镜像相关的元数据，主要包括镜像的架构、镜像默认配置信息、rootfs等</p>
<ul>
<li>layer</li>
</ul>
<p>镜像层元数据，保存着每一层镜像的实际内容，单个layer可被多个镜像共享</p>
<h2 id="镜像本地管理"><a href="#镜像本地管理" class="headerlink" title="镜像本地管理"></a>镜像本地管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu /v/l/d/i/overlay2# pwd</span><br><span class="line">/var/lib/docker/image/overlay2</span><br><span class="line">root@ubuntu /v/l/d/i/overlay2# ls</span><br><span class="line">distribution/  imagedb/  layerdb/  repositories.json</span><br></pre></td></tr></table></figure>

<p>docker pull所下载的镜像都存储在这个目录下（以overlay2为例）。</p>
<h3 id="repositories-json"><a href="#repositories-json" class="headerlink" title="repositories.json"></a>repositories.json</h3><p>repositories.json中记录了和本地image相关的repository信息，主要是name和image id的对应关系，当image从registry上被pull下来后，就会更新该文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu /v/l/d/i/overlay2# cat repositories.json | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Repositories&quot;: &#123;</span><br><span class="line">        &quot;busybox&quot;: &#123;  # 镜像的名字</span><br><span class="line">            &quot;busybox:latest&quot;: &quot;sha256:beae173ccac6ad749f76713cf4440fe3d21d1043fe616dfbe30775815d1d0f6a&quot;,</span><br><span class="line">            &quot;busybox@sha256:5acba83a746c7608ed544dc1533b87c737a0b0fb730301639a0179f9344b1678&quot;: &quot;sha256:beae173ccac6ad749f76713cf4440fe3d21d1043fe616dfbe30775815d1d0f6a&quot;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每一个repository里不同版本对应的镜像id。找到镜像id后，就可以查看镜像内容，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu /v/l/d/i/o/i/c/sha256# cat beae173ccac6ad749f76713cf4440fe3d21d1043fe616dfbe30775815d1d0f6a | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    &quot;architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">    &quot;config&quot;: &#123;</span><br><span class="line">        &quot;Hostname&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">        &quot;User&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AttachStdin&quot;: false,</span><br><span class="line">        &quot;AttachStdout&quot;: false,</span><br><span class="line">        &quot;AttachStderr&quot;: false,</span><br><span class="line">        &quot;Tty&quot;: false,</span><br><span class="line">        &quot;OpenStdin&quot;: false,</span><br><span class="line">        &quot;StdinOnce&quot;: false,</span><br><span class="line">        &quot;Env&quot;: [</span><br><span class="line">            &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Cmd&quot;: [</span><br><span class="line">            &quot;sh&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:da658412c37aa24e561eb7e16c61bc82a9711340d8fb5cf1a8f39d8e96d7f723&quot;,</span><br><span class="line">        &quot;Volumes&quot;: null,</span><br><span class="line">        &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Entrypoint&quot;: null,</span><br><span class="line">        &quot;OnBuild&quot;: null,</span><br><span class="line">        &quot;Labels&quot;: null</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;container&quot;: &quot;a0007fa726185ffbcb68e90f8edabedd79a08949f32f4f0bcc6e5fed713a72c8&quot;,</span><br><span class="line">    &quot;container_config&quot;: &#123;</span><br><span class="line">        &quot;Hostname&quot;: &quot;a0007fa72618&quot;,</span><br><span class="line">        &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">        &quot;User&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AttachStdin&quot;: false,</span><br><span class="line">        &quot;AttachStdout&quot;: false,</span><br><span class="line">        &quot;AttachStderr&quot;: false,</span><br><span class="line">        &quot;Tty&quot;: false,</span><br><span class="line">        &quot;OpenStdin&quot;: false,</span><br><span class="line">        &quot;StdinOnce&quot;: false,</span><br><span class="line">        &quot;Env&quot;: [</span><br><span class="line">            &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Cmd&quot;: [</span><br><span class="line">            &quot;/bin/sh&quot;,</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;#(nop) &quot;,</span><br><span class="line">            &quot;CMD [\&quot;sh\&quot;]&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:da658412c37aa24e561eb7e16c61bc82a9711340d8fb5cf1a8f39d8e96d7f723&quot;,</span><br><span class="line">        &quot;Volumes&quot;: null,</span><br><span class="line">        &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Entrypoint&quot;: null,</span><br><span class="line">        &quot;OnBuild&quot;: null,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;created&quot;: &quot;2021-12-30T19:19:41.006954958Z&quot;,</span><br><span class="line">    &quot;docker_version&quot;: &quot;20.10.7&quot;,</span><br><span class="line">    &quot;history&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;created&quot;: &quot;2021-12-30T19:19:40.833034683Z&quot;,</span><br><span class="line">            &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:6db446a57cbd2b7f4cfde1f280177b458390ed5a6d1b54c6169522bc2c4d838e in / &quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;created&quot;: &quot;2021-12-30T19:19:41.006954958Z&quot;,</span><br><span class="line">            &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  CMD [\&quot;sh\&quot;]&quot;,</span><br><span class="line">            &quot;empty_layer&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;os&quot;: &quot;linux&quot;,</span><br><span class="line">    &quot;rootfs&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;layers&quot;,</span><br><span class="line">        &quot;diff_ids&quot;: [</span><br><span class="line">            &quot;sha256:01fd6df81c8ec7dd24bbbd72342671f41813f992999a3471b9d9cbc44ad88374&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中我们可以看到上面提及的镜像架构、镜像配置等，其中我们可以通过rootfs找到镜像对应的layer。busybody镜像只有一层layer。</p>
<p>通过diff-id我们就可以找到cache-id（内容寻址），如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu /v/l/d/i/o/l/s/01fd6df81c8ec7dd24bbbd72342671f41813f992999a3471b9d9cbc44ad88374# cat cache-id</span><br><span class="line">0ea32e289a2f802c5b3abce02d8a4fe10dfff3049c4693276153c02da6f2e149⏎</span><br></pre></td></tr></table></figure>

<p>找到cache-id，就可以知道这一层镜像实际存放的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu /v/l/d/o/0ea32e289a2f802c5b3abce02d8a4fe10dfff3049c4693276153c02da6f2e149# ls diff/</span><br><span class="line">bin/  dev/  etc/  home/  root/  tmp/  usr/  var/</span><br><span class="line">root@ubuntu /v/l/d/o/0ea32e289a2f802c5b3abce02d8a4fe10dfff3049c4693276153c02da6f2e149# cat link</span><br><span class="line">RBOMEOEKWMWD37H4SKJRUNYWK2⏎                                                                                                                                                                                   root@ubuntu /v/l/d/o/0ea32e289a2f802c5b3abce02d8a4fe10dfff3049c4693276153c02da6f2e149# pwd</span><br><span class="line">/var/lib/docker/overlay2/0ea32e289a2f802c5b3abce02d8a4fe10dfff3049c4693276153c02da6f2e149</span><br></pre></td></tr></table></figure>

<p>以上示例是只有一层镜像的情况，对于多层镜像需要通过计算chain-id，得到cache-id。</p>
<p>计算chainid时，用到了所有祖先layer的信息，从而能保证根据chainid得到的rootfs是唯一的。比如我在debian和ubuntu的image基础上都添加了一个同样的文件，那么commit之后新增加的这两个layer具有相同的内容，相同的diffid，但由于他们的父layer不一样，所以他们的chainid会不一样，从而根据chainid能找到唯一的rootfs。</p>
<p><code>chainID 需通过公式 chainID(n) = SHA256(chain(n-1) diffID(n)) 计算得到</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-node-1 layerdb]# echo -n &quot;sha256:ccdbb80308cc5ef43b605ac28fac29c6a597f89f5a169bbedbb8dec29c987439 sha256:63c99163f47292f80f9d24c5b475751dbad6dc795596e935c5c7f1c73dc08107&quot; | sha256sum -</span><br><span class="line">8d8dceacec7085abcab1f93ac1128765bc6cf0caac334c821e01546bd96eb741  -</span><br><span class="line"></span><br><span class="line">[root@k8s-master-node-1 8d8dceacec7085abcab1f93ac1128765bc6cf0caac334c821e01546bd96eb741]# ls</span><br><span class="line">cache-id  diff  parent  size  tar-split.json.gz</span><br><span class="line">[root@k8s-master-node-1 8d8dceacec7085abcab1f93ac1128765bc6cf0caac334c821e01546bd96eb741]# cat cache-id</span><br><span class="line">4d615a437c68f0853db7749bf3d7d268efaebbe045a2af4d8b8e1148fc1acd91</span><br></pre></td></tr></table></figure>



<h2 id="docker容器与镜像"><a href="#docker容器与镜像" class="headerlink" title="docker容器与镜像"></a>docker容器与镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu /v/l/d/o/0ea32e289a2f802c5b3abce02d8a4fe10dfff3049c4693276153c02da6f2e149# mount | grep overlay</span><br><span class="line">overlay on /var/lib/docker/overlay2/c982ec89c32ca002642cee045d28afcea7659f4bf0ef6eb0ef73ac00800c0b07/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/6MZ24T7INBRKWZP6KQNKLY2HJL:/var/lib/docker/overlay2/l/RBOMEOEKWMWD37H4SKJRUNYWK2,upperdir=/var/lib/docker/overlay2/c982ec89c32ca002642cee045d28afcea7659f4bf0ef6eb0ef73ac00800c0b07/diff,workdir=/var/lib/docker/overlay2/c982ec89c32ca002642cee045d28afcea7659f4bf0ef6eb0ef73ac00800c0b07/work)</span><br></pre></td></tr></table></figure>

<p>可以看到，启动容器会 mount 一个 overlay 的联合文件系统到容器内。这个文件系统由三层组成：</p>
<ul>
<li>lowerdir：只读层，即为镜像的镜像层，为layer的短id</li>
<li>upperdir：读写层，该层是容器的读写层，对容器的读写操作将反映在读写层。</li>
<li>workdir： overlayfs 的内部层，用于实现从只读层到读写层的 copy_up 操作。</li>
<li>merge：容器内作为同一视图联合挂载点的目录。</li>
</ul>
<h1 id="Docker容器卷"><a href="#Docker容器卷" class="headerlink" title="Docker容器卷"></a>Docker容器卷</h1><h2 id="什么是容器卷"><a href="#什么是容器卷" class="headerlink" title="什么是容器卷"></a>什么是容器卷</h2><p>如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化  </p>
<p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！<br>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！  </p>
<h2 id="使用容器卷"><a href="#使用容器卷" class="headerlink" title="使用容器卷"></a>使用容器卷</h2><ul>
<li><p>直接使用命令挂载 -v</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录</span><br><span class="line"></span><br><span class="line"># 通过 docker inspect 容器ID 查看挂载信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器卷挂载方式</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载</span></span><br><span class="line">docker run -d --name niming -v /home/ljt ubuntu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具名挂载</span></span><br><span class="line">docker run -d --name juming -v JuMing:/home/juming ubuntu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定路径挂载， 这种挂载方式docker volume <span class="built_in">ls</span>是找不到的</span></span><br><span class="line">docker run -d --name lujing -v /home/docker/volume:/home/juming ubuntu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看卷信息</span></span><br><span class="line">howu@howu-ubuntu:~/sambaDoc$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               JuMing</span><br><span class="line">local               f0e64f8aba5f9a68765b8a4dc2ba9576d04a83d94b1f3b6ee4ce7684284f2c8e</span><br><span class="line"></span><br><span class="line">howu@howu-ubuntu:~/sambaDoc$ docker volume inspect JuMing</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2020-11-29T18:04:59+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/JuMing/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;JuMing&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 容器内路径： ro rw 改变读写权限</span></span><br><span class="line">ro #readonly 只读</span><br><span class="line">rw #readwrite 可读可写</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span></span><br></pre></td></tr></table></figure>



<h2 id="初识Dockerfile"><a href="#初识Dockerfile" class="headerlink" title="初识Dockerfile"></a>初识Dockerfile</h2><p>DockerFile用来构建镜像的构建文件，是一个命令脚本，通过这个脚本可以生成镜像。</p>
<p><strong>实验：</strong>通过DockerFile自己创建一个镜像，实现数据卷挂载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dockerfile脚本</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume01&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>执行后的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu ~/s/d/dockerfile&gt; docker build -f /home/howu/sambaDoc/docker/dockerfile/dockerfile_myubuntu  -t ljt/ubuntu:1.0 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM centos</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">0d120b6ccaa8</span></span><br><span class="line">Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume01&quot;]</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> 6a8eb0a835e1</span></span><br><span class="line">Removing intermediate container 6a8eb0a835e1</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">08f163e4eebd</span></span><br><span class="line">Step 3/4 : CMD echo &quot;----end----&quot;</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> aaf30891f017</span></span><br><span class="line">Removing intermediate container aaf30891f017</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">13d730977a6d</span></span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> 29b3539587b9</span></span><br><span class="line">Removing intermediate container 29b3539587b9</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">c8894d001c35</span></span><br><span class="line">Successfully built c8894d001c35</span><br><span class="line">Successfully tagged ljt/ubuntu:1.0</span><br><span class="line">howu@howu-ubuntu ~/s/d/dockerfile&gt; docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ljt/ubuntu          1.0                 c8894d001c35        22 seconds ago      215MB</span><br><span class="line">ubuntu-vim          latest              c1bcb16c3615        7 days ago          167MB</span><br><span class="line">ubuntu              latest              f643c72bc252        10 days ago         72.9MB</span><br><span class="line">centos              latest              0d120b6ccaa8        3 months ago        215MB</span><br><span class="line">hello-world         latest              bf756fb1ae65        11 months ago       13.3kB</span><br></pre></td></tr></table></figure>

<p>运行自己创建的镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu:~$ docker run -it --name docker1 c8894d001c35</span><br><span class="line">[root@cb10ce51c04a /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01</span><br></pre></td></tr></table></figure>


<h2 id="容器间数据卷"><a href="#容器间数据卷" class="headerlink" title="容器间数据卷"></a>容器间数据卷</h2><p><strong>实验：</strong>容器间数据共享  <code>--volumes-from</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu ~/s/d/dockerfile&gt; docker run -it --name docker2 --volumes-from docker1 c8894d001c35</span><br><span class="line">[root@e279f4fdab7e /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01</span><br><span class="line">[root@e279f4fdab7e /]# cd volume01/</span><br><span class="line">[root@e279f4fdab7e volume01]# ls</span><br><span class="line">ljt.txt</span><br><span class="line">[root@e279f4fdab7e volume01]#</span><br></pre></td></tr></table></figure>

<p><code>ps</code>删除其中一个容器，其他容器的数据不会丢失。</p>
<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h2 id="DockerFile介绍"><a href="#DockerFile介绍" class="headerlink" title="DockerFile介绍"></a>DockerFile介绍</h2><p>DockerFile是一个文本格式的配置文件（命令参数脚本），用户可以使用DockerFile来快速创建自定义的镜像。</p>
<p><strong>构建步骤：</strong></p>
<p>1、编写一个DockerFile文件</p>
<p>2、docker build构建一个镜像</p>
<p>3、docker run运行镜像</p>
<p>4、docker push发布镜像（DockerHub、阿里云镜像）</p>
<p>很多官方镜像包都是基础包，我们可以通过DockerFile构建自己的镜像。</p>
<h2 id="DockerFile语法"><a href="#DockerFile语法" class="headerlink" title="DockerFile语法"></a>DockerFile语法</h2><p>1、每个保留关键字(指令）都是必须是大写字母<br>2、执行从上到下顺序<br>3、#表示注释<br>4、每一个指令都会创建提交一个新的镜像曾，并提交！  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DockerFile常用指令</span></span><br><span class="line">FROM 				# 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER 			# 镜像是谁写的， 姓名+邮箱</span><br><span class="line">RUN 				# 镜像构建的时候需要运行的命令</span><br><span class="line">ADD 				# 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录</span><br><span class="line">WORKDIR 			# 镜像的工作目录</span><br><span class="line">VOLUME			 	# 挂载的目录</span><br><span class="line">EXPOSE 				# 保留端口配置</span><br><span class="line">CMD 				# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span><br><span class="line">ENTRYPOINT 			# 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD 			# 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。</span><br><span class="line">COPY 				# 类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV 				# 构建的时候设置环境变量！</span><br></pre></td></tr></table></figure>



<h2 id="编写DockerFile"><a href="#编写DockerFile" class="headerlink" title="编写DockerFile"></a>编写DockerFile</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER laijiatao&lt;496272917@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;---end---&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>


<blockquote>
<p>运行：通过DockerFile文件构建镜像</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker build -f 文件路径 -t 镜像名:[tag] .</span></span><br><span class="line">docker build -f mydockerfile-centos -t mycentos:0.1 .</span><br></pre></td></tr></table></figure>



<blockquote>
<p>CMD与ENTRYPOINT区别</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span><br><span class="line">ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640095.png" alt="请添加图片描述"></p>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>在启动容器时，通过加入-p -P参数来指定端口映射，实现容器外部网络访问容器内的网络应用和服务。</p>
<h2 id="容器互联-–link"><a href="#容器互联-–link" class="headerlink" title="容器互联 –link"></a>容器互联 –link</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建两个容器</span></span><br><span class="line">docker run -d --name tomcat01 tomcat</span><br><span class="line">docker run -d --name tomcat02 tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两个容器间ping不通</span></span><br><span class="line">howu@howu-ubuntu:~$ docker exec -it tomcat02 ping tomcat01</span><br><span class="line">ping: tomcat01: No address associated with hostname</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用--<span class="built_in">link</span>使两个容器互联</span></span><br><span class="line">howu@howu-ubuntu:~$ docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br><span class="line">7d3cd10676bf6e43383f47e690650d8f305314d2022919b65b12e2505077d3aa</span><br><span class="line">howu@howu-ubuntu:~$ docker exec -it tomcat03 ping tomcat02</span><br><span class="line">PING tomcat02 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=8.74 ms</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.050 ms</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.045 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat02 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 16ms</span><br><span class="line">rtt min/avg/max/mdev = 0.045/2.944/8.739/4.097 ms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但是用tomcat02 ping不通 tomcat03</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用docker inspect 容器查看信息</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640250.png" alt="请添加图片描述"></p>
<p>查看tomcat03里面的&#x2F;etc&#x2F;hosts发现有tomcat02的配置<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640955.png" alt="请添加图片描述"></p>
<blockquote>
<p>–link的本质就是在hosts配置中添加映射</p>
</blockquote>
<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><blockquote>
<p>使用docker network ls查看docker网络<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640057.png" alt="请添加图片描述"></p>
</blockquote>
<p><strong>网络模式</strong></p>
<p>bridge ：桥接 docker（默认，自己创建也是用bridge模式）</p>
<p>none ：不配置网络，一般不用</p>
<p>host ：和所主机共享网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当直接启动一个容器时，默认是使用bridge，就是我们得docker0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义一个网络</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640131.png" alt="请添加图片描述"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect mynet</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640592.png" alt="请添加图片描述"></p>
<blockquote>
<p>使用自定义网络启动两个容器</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640521.png" alt="请添加图片描述"></p>
<blockquote>
<p>再次查看mynet网络</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640288.png" alt="请添加图片描述"></p>
<p>此时两个容器间可以相互ping通。</p>
<h2 id="添加容器到自定义网路"><a href="#添加容器到自定义网路" class="headerlink" title="添加容器到自定义网路"></a>添加容器到自定义网路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu:~$ docker network connect --help</span><br><span class="line"></span><br><span class="line">Usage:  docker network connect [OPTIONS] NETWORK CONTAINER</span><br><span class="line"></span><br><span class="line">Connect a container to a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --alias strings           Add network-scoped alias for the container</span><br><span class="line">      --driver-opt strings      driver options for the network</span><br><span class="line">      --ip string               IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string              IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --link list               Add link to another container</span><br><span class="line">      --link-local-ip strings   Add a link-local address for the container</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">howu@howu-ubuntu:~$ docker exec tomact-mtnet-01 ping tomcat04</span><br><span class="line">PING tomcat04 (192.168.0.4) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat04.mynet (192.168.0.4): icmp_seq=1 ttl=64 time=0.184 ms</span><br><span class="line">64 bytes from tomcat04.mynet (192.168.0.4): icmp_seq=2 ttl=64 time=0.052 ms</span><br><span class="line">64 bytes from tomcat04.mynet (192.168.0.4): icmp_seq=3 ttl=64 time=0.081 ms</span><br><span class="line">^C</span><br><span class="line">howu@howu-ubuntu:~$ docker exec tomact-mtnet-02 ping tomcat04</span><br><span class="line">PING tomcat04 (192.168.0.4) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat04.mynet (192.168.0.4): icmp_seq=1 ttl=64 time=0.074 ms</span><br><span class="line">64 bytes from tomcat04.mynet (192.168.0.4): icmp_seq=2 ttl=64 time=0.060 ms</span><br><span class="line">^C</span><br><span class="line">howu@howu-ubuntu:~$ docker exec tomcat04 ping tomact-mtnet-02</span><br><span class="line">PING tomact-mtnet-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomact-mtnet-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.065 ms</span><br><span class="line">64 bytes from tomact-mtnet-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.055 ms</span><br><span class="line">^C</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Docker-运行容器概述"><a href="#Docker-运行容器概述" class="headerlink" title="Docker 运行容器概述"></a>Docker 运行容器概述</h1><h2 id="docker进程关系图"><a href="#docker进程关系图" class="headerlink" title="docker进程关系图"></a>docker进程关系图</h2><p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051640246.png" alt="img"><br>以运行hello-world容器为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                              +------------+</span><br><span class="line">                              |            |</span><br><span class="line">                              | Docker Hub |</span><br><span class="line">                              |            |</span><br><span class="line">                              +------------+</span><br><span class="line">                                    ↑</span><br><span class="line">                                    |</span><br><span class="line">                                  2 | REST</span><br><span class="line">                                    |</span><br><span class="line">                                    ↓</span><br><span class="line">                               +---------+</span><br><span class="line">+--------+       REST          |         |    grpc      +-------------------+</span><br><span class="line">| docker |&lt;-------------------&gt;| dockerd |&lt;------------&gt;| docker-containerd |</span><br><span class="line">+--------+         1           |         |      3       +-------------------+</span><br><span class="line">                               +---------+                       ↑</span><br><span class="line">                                                                 |</span><br><span class="line">                                                                 | 4</span><br><span class="line">                                                                 ↓</span><br><span class="line">                                                      +------------------------+  5   +-------------+</span><br><span class="line">                                                      | docker-containerd-shim |&lt;----&gt;| docker-runc |</span><br><span class="line">                                                      +------------------------+      +-------------+</span><br><span class="line">                                                                                             ↑</span><br><span class="line">                                                                                             | 6</span><br><span class="line">                                                                                             ↓</span><br><span class="line">                                                                                         +-------+</span><br><span class="line">                                                                                         | hello |</span><br><span class="line">                                                                                         +-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用<code>docker run</code>命令直接创建并运行一个容器，它的背后其实包含独立的两步，一步是<code>docker create</code>创建容器，另一步是<code>docker start</code>启动容器</p>
<h2 id="docker-creat"><a href="#docker-creat" class="headerlink" title="docker creat"></a>docker creat</h2><h3 id="为容器设置读写层"><a href="#为容器设置读写层" class="headerlink" title="为容器设置读写层"></a>为容器设置读写层</h3><p>以容器id为名字创建容器层。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := idtools.MkdirAs(path.Join(dir, <span class="string">&quot;diff&quot;</span>), <span class="number">0755</span>, rootUID, rootGID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lid := generateID(idLength)</span><br><span class="line"><span class="keyword">if</span> err := os.Symlink(path.Join(<span class="string">&quot;..&quot;</span>, id, <span class="string">&quot;diff&quot;</span>), path.Join(d.home, linkDir, lid)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write link id to link file</span></span><br><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(path.Join(dir, <span class="string">&quot;link&quot;</span>), []<span class="type">byte</span>(lid), <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if no parent directory, done</span></span><br><span class="line"><span class="keyword">if</span> parent == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := idtools.MkdirAs(path.Join(dir, <span class="string">&quot;work&quot;</span>), <span class="number">0700</span>, rootUID, rootGID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := idtools.MkdirAs(path.Join(dir, <span class="string">&quot;merged&quot;</span>), <span class="number">0700</span>, rootUID, rootGID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="创建容器配置文件"><a href="#创建容器配置文件" class="headerlink" title="创建容器配置文件"></a>创建容器配置文件</h3><p>docker将用户指定的参数和image配置文件中的部分参数进行合并，然后将合并后生成的容器的配置文件放在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;下面，目录名称就是容器的ID，主要有两个配置文件：</p>
<ul>
<li>容器相关配置文件config.v2.json</li>
</ul>
<p>容器id、容器镜像、容器环境变量、容器执行命令、容器网络设置等</p>
<ul>
<li>主机相关配置文件hostconfig.json</li>
</ul>
<p>网络模式、容器能力、内存大小、cpu配额、ulimit等</p>
<h2 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start"></a>docker start</h2><h3 id="准备rootfs"><a href="#准备rootfs" class="headerlink" title="准备rootfs"></a>准备rootfs</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir, err := container.RWLayer.Mount(container.GetMountLabel())</span><br></pre></td></tr></table></figure>

<p>容器在create阶段，已经准备好所有的layer，在容器start阶段，一开始，就通过mount的方式将所有的layer合并起来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并的层</span></span><br><span class="line">opts = fmt.Sprintf(<span class="string">&quot;lowerdir=%s,upperdir=%s,workdir=%s&quot;</span>, <span class="type">string</span>(lowers), path.Join(id, <span class="string">&quot;diff&quot;</span>), path.Join(id, <span class="string">&quot;work&quot;</span>))</span><br><span class="line"><span class="comment">// mount</span></span><br><span class="line"><span class="keyword">if</span> err := mount(<span class="string">&quot;overlay&quot;</span>, mountTarget, <span class="string">&quot;overlay&quot;</span>, <span class="number">0</span>, mountData)</span><br></pre></td></tr></table></figure>

<p>合并的内容：</p>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051641040.png" alt="请添加图片描述"></p>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051641647.png" alt="请添加图片描述"></p>
<h3 id="初始化网络"><a href="#初始化网络" class="headerlink" title="初始化网络"></a>初始化网络</h3><p>容器分为4种网络模式：</p>
<ul>
<li>host</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将宿主机的hostname赋值给新建container</span></span><br><span class="line">container.Config.Hostname, err = os.Hostname()</span><br></pre></td></tr></table></figure>



<ul>
<li>container</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所要共享网络的container的hosts文件</span></span><br><span class="line">nc, err := daemon.getNetworkedContainer(container.ID, container.HostConfig.NetworkMode.ConnectedContainer())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将所要共享网络的container的HostnamePath、HostsPath和ResolvConfPath赋值给新container</span></span><br><span class="line">initializeNetworkingPaths(container, nc)</span><br><span class="line"><span class="comment">//将所要共享网络的container的Hostname、Domainname赋值给新container</span></span><br><span class="line">container.Config.Hostname = nc.Config.Hostname</span><br><span class="line">container.Config.Domainname = nc.Config.Domainname</span><br></pre></td></tr></table></figure>



<ul>
<li>null</li>
<li>bridge（default）</li>
</ul>
<p>(1) 若网络模式为container模式，则说明容器与其他容器共用网络。首先找到被引用的容器对象，然后让新容器使用被引用容器的hostname、hosts、resolv.conf文件，并和被引用主机同一个主机名和域名。<br>(2) 若网络模式为host模式，则将容器的主机名和域名设置为与主机相同。首先调用os. Hostname()获取宿主机的主机名，分离出主机名和域名分别填写到容器Config对应的域中，然后继续执行下一步。<br>(3) host模式或其他情况则执行allocateNetwork函数，然后创建hostname文件并填入域名和主机名。allocateNetwork函数主要为容器清理遗留的Sandbox，更新NetworkSettings属性，并对每一个容器加入的网络调用connectToNetwork函数。connectToNetwork函数会调用libnetwork. network.CreateEndpoint和libnetwork.controller.NewSandbox为容器当前网络创建Endpoint和Sandbox（Sandbox对应一个容器，仅创建一次），将Endpoint加入到该Sandbox中，以及为容器更新NetworkSettings属性。</p>
<p><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051641845.png" alt="在这里插入图片描述"></p>
<h3 id="生成bundle配置文件"><a href="#生成bundle配置文件" class="headerlink" title="生成bundle配置文件"></a>生成bundle配置文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(filepath.Join(container.dir, configFilename))</span><br></pre></td></tr></table></figure>

<p>config.json文件就是Container Configuration file，这个是容器运行时所必须的文件。关于该文件的具体说明，可以参考<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runtime-spec/blob/main/config.md#configuration-schema-example">容器运行时规范</a></p>
<p>路径：&#x2F;run&#x2F;containerd&#x2F;io.containerd.runtime.v1.linux&#x2F;moby&#x2F;</p>
<h3 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h3><p>待容器启动之后，containerd还需要监听容器的OOM事件和容器退出事件。</p>
<h3 id="shim"><a href="#shim" class="headerlink" title="shim"></a>shim</h3><p>shim进程被containerd启动之后，第一步是设置子孙进程成为孤儿进程后由shim进程接管，即shim将变成孤儿进程的父进程，这样就保证容器里的第一个进程不会因为runc进程的退出而被init进程接管。</p>
<h3 id="runc"><a href="#runc" class="headerlink" title="runc"></a>runc</h3><p>runc会被调用两次，第一次是shim调用<code>runc create</code>创建容器，第二次是containerd调用<code>runc start</code>启动容器。</p>
<h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p>runc会根据参数中传入的bundle目录名称以及容器ID，创建容器.</p>
<p>创建容器就是启动进程<code>/proc/self/exe init</code>，由于&#x2F;proc&#x2F;self&#x2F;exe指向的是自己，所以相当于fork了一个新进程，并且新进程启动的参数是init，相当于运行了<code>runc init</code>，<code>runc init</code>会根据配置创建好相应的namespace，同时创建一个叫exec.fifo的临时文件，等待其它进程打开这个文件，如果有其它进程打开这个文件，则启动容器。</p>
<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>启动容器就是运行<code>runc start</code>，它会打开并读一下文件exec.fifo，这样就会触发<code>runc init</code>进程启动容器，如果<code>runc start</code>读取该文件没有异常，将会删掉文件exec.fifo，所以一般情况下我们看不到文件exec.fifo。</p>
<ol>
<li>运行<code>runc create</code>时，后台生成该命令的进程，我们称该进程为parent；</li>
<li>parent进程中运行<code>runc init</code>，我们称<code>runc init</code>进程为child进程；</li>
<li>child进程开始准备用户进程的运行环境，此时parent和child进程通过pipe进行通信；</li>
<li>child进程准备好用户进程的运行环境后，通知parent退出，自己则被exec.fifo阻塞；</li>
<li>由于parent退出(即<code>runc create</code>退出)，child成孤独进程，进而被1进程接收；</li>
<li>child进程一直被exec.fifo阻塞；</li>
<li>运行<code>runc start</code>时，会打开exec.fifo，使child的阻塞消除，<code>runc start</code>退出；</li>
<li>由于阻塞消除，child进程继续往下执行；</li>
<li>child进程使用用户定义的命令替换<code>runc init</code>，从而child进程成为容器内的主进程；</li>
<li>容器启动完成。</li>
</ol>
<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><h2 id="container-shim进程参数"><a href="#container-shim进程参数" class="headerlink" title="container-shim进程参数"></a>container-shim进程参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root      34919   1524  0 6月15 ?       00:00:09 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/99c136f8c75c6f94b38c92b22a15a5beea4de1059540a2ac2b95856488a4987e -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="io文件"><a href="#io文件" class="headerlink" title="io文件"></a>io文件</h2><p>&#x2F;run&#x2F;docker&#x2F;containerd&#x2F;<br>文件占用情况<br><img src="https://raw.githubusercontent.com/howu911/picx-images-hosting/master/docker_stu202410051641709.png" alt="在这里插入图片描述"></p>
<h2 id="运行状态文件"><a href="#运行状态文件" class="headerlink" title="运行状态文件"></a>运行状态文件</h2><pre><code>/run/docker/runtime-runc/moby/
</code></pre>
<h1 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://opencontainers.org/about/overview/">oci</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"># Docker</a>
          </div>

        

    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">howu</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"howu911/blog-comments","repo_id":"R_kgDOM75Hug","category":"Announcements","category_id":"DIC_kwDOM75Hus4CjHIc","mapping":"pathname","strict":0,"reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"en","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
